// Code generated by github.com/Khan/genqlient, DO NOT EDIT.

package eff

import (
	"context"

	"github.com/Khan/genqlient/graphql"
	"github.com/google/uuid"
)

// ActivityQueryEntriesEntryConnection includes the requested fields of the GraphQL type EntryConnection.
// The GraphQL type's documentation follows.
//
// Connection to a list of Entry nodes.
// Access Entry nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
// Use `pageInfo` to paginate responses using the cursors provided.
type ActivityQueryEntriesEntryConnection struct {
	Nodes []*ActivityQueryEntriesEntryConnectionNodesEntry `json:"nodes"`
}

// GetNodes returns ActivityQueryEntriesEntryConnection.Nodes, and is useful for accessing the field via an interface.
func (v *ActivityQueryEntriesEntryConnection) GetNodes() []*ActivityQueryEntriesEntryConnectionNodesEntry {
	return v.Nodes
}

// ActivityQueryEntriesEntryConnectionNodesEntry includes the requested fields of the GraphQL type Entry.
// The GraphQL type's documentation follows.
//
// An entry represents one side of a transaction in a ledger. In other systems, these may be called "ledger lines" or "journal entries".
//
// Entries always have an account, amount, and direction (CREDIT or DEBIT). In addition, Twisp uses the concept of "entry types" to assign every entry to a categorical type.
//
// Twisp enforces double-entry accounting, which in practice means that entries can only be entered in the context of a Transaction. Posting a transaction will create _at least 2_ ledger entries.
type ActivityQueryEntriesEntryConnectionNodesEntry struct {
	// Arbitrary structured data about this entry.
	Metadata *map[string]interface{} `json:"metadata"`
	// Amount of the ledger entry using the currency-supported Money type.
	Amount ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney `json:"amount"`
}

// GetMetadata returns ActivityQueryEntriesEntryConnectionNodesEntry.Metadata, and is useful for accessing the field via an interface.
func (v *ActivityQueryEntriesEntryConnectionNodesEntry) GetMetadata() *map[string]interface{} {
	return v.Metadata
}

// GetAmount returns ActivityQueryEntriesEntryConnectionNodesEntry.Amount, and is useful for accessing the field via an interface.
func (v *ActivityQueryEntriesEntryConnectionNodesEntry) GetAmount() ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney {
	return v.Amount
}

// ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney includes the requested fields of the GraphQL type Money.
// The GraphQL type's documentation follows.
//
// Money type with multi-currency support.
//
// Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.
//
// Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.
//
// | Currency | Units    | Formatted |
// |----------|----------|-----------|
// | USD      | `289.27` | $289.27   |
// | BHD      | `28.927` | 28.927 BD |
// | JPY      | `28927`  | ¥28927    |
type ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney struct {
	Units Decimal `json:"units"`
}

// GetUnits returns ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney.Units, and is useful for accessing the field via an interface.
func (v *ActivityQueryEntriesEntryConnectionNodesEntryAmountMoney) GetUnits() Decimal { return v.Units }

// ActivityQueryResponse is returned by ActivityQuery on success.
type ActivityQueryResponse struct {
	// Select one or more entries. Specify the index to use and apply filters to your query.
	Entries ActivityQueryEntriesEntryConnection `json:"entries"`
}

// GetEntries returns ActivityQueryResponse.Entries, and is useful for accessing the field via an interface.
func (v *ActivityQueryResponse) GetEntries() ActivityQueryEntriesEntryConnection { return v.Entries }

// CreateActivityIndexResponse is returned by CreateActivityIndex on success.
type CreateActivityIndexResponse struct {
	// Mutations in the `schema` namespace are used to manage custom indexes, aggregates, and historical indexes. Use the `schema` namespace to create and delete indexes and aggregates.
	Schema CreateActivityIndexSchemaSchemaMutation `json:"schema"`
}

// GetSchema returns CreateActivityIndexResponse.Schema, and is useful for accessing the field via an interface.
func (v *CreateActivityIndexResponse) GetSchema() CreateActivityIndexSchemaSchemaMutation {
	return v.Schema
}

// CreateActivityIndexSchemaSchemaMutation includes the requested fields of the GraphQL type SchemaMutation.
type CreateActivityIndexSchemaSchemaMutation struct {
	// Create a custom index for querying records. Currently available for indexing Account, AccountSet, Balance, Entry, Transaction, and TranCode record types.
	//
	// To query the index, use the `CUSTOM` index type for the applicable resource query and supply the filter inputs specified by the index.
	//
	// Custom indexes can be created using fields on the root level of the record like `Account.modified` as well as nested fields within documents like the `metadata` object.
	//
	// Depending on the parameters defined, custom indexes may be structured to return a single record or a sorted list of records.
	//
	// Note that due to the scaling properties of the underlying database, a single partition supports a fixed amount of read bandwidth and individual write operations per second. Beyond that threshold, throttling will occur. Visit scaling properties for more information.
	//
	// When designing custom indexes, care must be taken to ensure that reads and writes are spread across a sufficient number of partitions to support peak workloads. In practice, partitioning by account is usually sufficient. Our technical support staff is available for guidance on partition design patterns at [support@twisp.com](mailto:support@twisp.com).
	//
	// To learn more about indexes within the Twisp FLDB, see [Index-First Design](https://www.twisp.com/docs/infrastructure/ledger-database#index-first-design) in the docs.
	CreateIndex CreateActivityIndexSchemaSchemaMutationCreateIndex `json:"createIndex"`
}

// GetCreateIndex returns CreateActivityIndexSchemaSchemaMutation.CreateIndex, and is useful for accessing the field via an interface.
func (v *CreateActivityIndexSchemaSchemaMutation) GetCreateIndex() CreateActivityIndexSchemaSchemaMutationCreateIndex {
	return v.CreateIndex
}

// CreateActivityIndexSchemaSchemaMutationCreateIndex includes the requested fields of the GraphQL type Index.
type CreateActivityIndexSchemaSchemaMutationCreateIndex struct {
	// The type of record this index applies to.
	On IndexOnEnum `json:"on"`
}

// GetOn returns CreateActivityIndexSchemaSchemaMutationCreateIndex.On, and is useful for accessing the field via an interface.
func (v *CreateActivityIndexSchemaSchemaMutationCreateIndex) GetOn() IndexOnEnum { return v.On }

// Record types which support custom indexes.
type IndexOnEnum string

const (
	IndexOnEnumAccount     IndexOnEnum = "Account"
	IndexOnEnumAccountset  IndexOnEnum = "AccountSet"
	IndexOnEnumBalance     IndexOnEnum = "Balance"
	IndexOnEnumTransaction IndexOnEnum = "Transaction"
	IndexOnEnumTrancode    IndexOnEnum = "TranCode"
	IndexOnEnumEntry       IndexOnEnum = "Entry"
)

var AllIndexOnEnum = []IndexOnEnum{
	IndexOnEnumAccount,
	IndexOnEnumAccountset,
	IndexOnEnumBalance,
	IndexOnEnumTransaction,
	IndexOnEnumTrancode,
	IndexOnEnumEntry,
}

// PostTransactionPostTransaction includes the requested fields of the GraphQL type Transaction.
// The GraphQL type's documentation follows.
//
// Transactions record all accounting events in the ledger. In Twisp, the only way to write to a ledger is through a transaction.
//
// Every transaction writes two or more entries to the ledger in standard double-entry accounting practice.
//
// Twisp expands upon the basic principle of an accounting transaction with additional features like transaction codes and correlations.
type PostTransactionPostTransaction struct {
	// Unique identifier for the transaction.
	TransactionId uuid.UUID `json:"transactionId"`
	// Date and time when the transaction was first posted.
	Created Timestamp `json:"created"`
}

// GetTransactionId returns PostTransactionPostTransaction.TransactionId, and is useful for accessing the field via an interface.
func (v *PostTransactionPostTransaction) GetTransactionId() uuid.UUID { return v.TransactionId }

// GetCreated returns PostTransactionPostTransaction.Created, and is useful for accessing the field via an interface.
func (v *PostTransactionPostTransaction) GetCreated() Timestamp { return v.Created }

// PostTransactionResponse is returned by PostTransaction on success.
type PostTransactionResponse struct {
	// Write a transaction to the ledger using the predefined defaults from the `tranCode` provided.
	PostTransaction PostTransactionPostTransaction `json:"postTransaction"`
}

// GetPostTransaction returns PostTransactionResponse.PostTransaction, and is useful for accessing the field via an interface.
func (v *PostTransactionResponse) GetPostTransaction() PostTransactionPostTransaction {
	return v.PostTransaction
}

// PostTransactionWithStatementDatePostTransaction includes the requested fields of the GraphQL type Transaction.
// The GraphQL type's documentation follows.
//
// Transactions record all accounting events in the ledger. In Twisp, the only way to write to a ledger is through a transaction.
//
// Every transaction writes two or more entries to the ledger in standard double-entry accounting practice.
//
// Twisp expands upon the basic principle of an accounting transaction with additional features like transaction codes and correlations.
type PostTransactionWithStatementDatePostTransaction struct {
	// Unique identifier for the transaction.
	TransactionId uuid.UUID `json:"transactionId"`
	// Date and time when the transaction was first posted.
	Created Timestamp `json:"created"`
}

// GetTransactionId returns PostTransactionWithStatementDatePostTransaction.TransactionId, and is useful for accessing the field via an interface.
func (v *PostTransactionWithStatementDatePostTransaction) GetTransactionId() uuid.UUID {
	return v.TransactionId
}

// GetCreated returns PostTransactionWithStatementDatePostTransaction.Created, and is useful for accessing the field via an interface.
func (v *PostTransactionWithStatementDatePostTransaction) GetCreated() Timestamp { return v.Created }

// PostTransactionWithStatementDateResponse is returned by PostTransactionWithStatementDate on success.
type PostTransactionWithStatementDateResponse struct {
	// Write a transaction to the ledger using the predefined defaults from the `tranCode` provided.
	PostTransaction PostTransactionWithStatementDatePostTransaction `json:"postTransaction"`
}

// GetPostTransaction returns PostTransactionWithStatementDateResponse.PostTransaction, and is useful for accessing the field via an interface.
func (v *PostTransactionWithStatementDateResponse) GetPostTransaction() PostTransactionWithStatementDatePostTransaction {
	return v.PostTransaction
}

// SetupBert_checkingAccount includes the requested fields of the GraphQL type Account.
// The GraphQL type's documentation follows.
//
// Accounts model all of the economic activity that your ledger provides.
//
// The chart of accounts is the basis for creating balance sheets, P&L reports, and for understanding the balances for the customer and business entities your business services.
//
// Accounts can be organized into sets with the AccountSet type. Hierarchical tree structures which roll up balances across many accounts can be modeled by nesting sets within other sets.
type SetupBert_checkingAccount struct {
	// Unique identifier for the account.
	AccountId uuid.UUID `json:"accountId"`
	// Account name. @example("Bill Pay Settlement") @example("Courtesy Credit")
	Name string `json:"name"`
}

// GetAccountId returns SetupBert_checkingAccount.AccountId, and is useful for accessing the field via an interface.
func (v *SetupBert_checkingAccount) GetAccountId() uuid.UUID { return v.AccountId }

// GetName returns SetupBert_checkingAccount.Name, and is useful for accessing the field via an interface.
func (v *SetupBert_checkingAccount) GetName() string { return v.Name }

// SetupCreateJournal includes the requested fields of the GraphQL type Journal.
// The GraphQL type's documentation follows.
//
// Journals allow for the organizing of transactions within separate "books".
//
// In many cases, users only need a single journal. For this reason, Twisp always contains a default journal with code `DEFAULT`.
//
// Journals can be used for a variety of functions. For example, users may create separate journals for different currencies, or product-specific journals.
type SetupCreateJournal struct {
	// Unique identifier for the journal.
	JournalId uuid.UUID `json:"journalId"`
}

// GetJournalId returns SetupCreateJournal.JournalId, and is useful for accessing the field via an interface.
func (v *SetupCreateJournal) GetJournalId() uuid.UUID { return v.JournalId }

// SetupCreateTranCode includes the requested fields of the GraphQL type TranCode.
// The GraphQL type's documentation follows.
//
// Transaction Codes (tran codes) are how financial engineers do double-entry accounting. They encode the basic patterns for a type of transaction as a predictable and repeatable formula.
//
// You can think of tran codes as function signatures which define how a transaction acts upon the ledger.
type SetupCreateTranCode struct {
	// Internal UUID for the transaction code record.
	TranCodeId uuid.UUID `json:"tranCodeId"`
}

// GetTranCodeId returns SetupCreateTranCode.TranCodeId, and is useful for accessing the field via an interface.
func (v *SetupCreateTranCode) GetTranCodeId() uuid.UUID { return v.TranCodeId }

// SetupErnie_checkingAccount includes the requested fields of the GraphQL type Account.
// The GraphQL type's documentation follows.
//
// Accounts model all of the economic activity that your ledger provides.
//
// The chart of accounts is the basis for creating balance sheets, P&L reports, and for understanding the balances for the customer and business entities your business services.
//
// Accounts can be organized into sets with the AccountSet type. Hierarchical tree structures which roll up balances across many accounts can be modeled by nesting sets within other sets.
type SetupErnie_checkingAccount struct {
	// Unique identifier for the account.
	AccountId uuid.UUID `json:"accountId"`
	// Account name. @example("Bill Pay Settlement") @example("Courtesy Credit")
	Name string `json:"name"`
}

// GetAccountId returns SetupErnie_checkingAccount.AccountId, and is useful for accessing the field via an interface.
func (v *SetupErnie_checkingAccount) GetAccountId() uuid.UUID { return v.AccountId }

// GetName returns SetupErnie_checkingAccount.Name, and is useful for accessing the field via an interface.
func (v *SetupErnie_checkingAccount) GetName() string { return v.Name }

// SetupResponse is returned by Setup on success.
type SetupResponse struct {
	// Create a new journal for recording transactions in the ledger.
	CreateJournal SetupCreateJournal `json:"createJournal"`
	// Create a new transaction code (tran code).
	CreateTranCode SetupCreateTranCode `json:"createTranCode"`
	// Create a new account.
	Ernie_checking SetupErnie_checkingAccount `json:"ernie_checking"`
	// Create a new account.
	Bert_checking SetupBert_checkingAccount `json:"bert_checking"`
}

// GetCreateJournal returns SetupResponse.CreateJournal, and is useful for accessing the field via an interface.
func (v *SetupResponse) GetCreateJournal() SetupCreateJournal { return v.CreateJournal }

// GetCreateTranCode returns SetupResponse.CreateTranCode, and is useful for accessing the field via an interface.
func (v *SetupResponse) GetCreateTranCode() SetupCreateTranCode { return v.CreateTranCode }

// GetErnie_checking returns SetupResponse.Ernie_checking, and is useful for accessing the field via an interface.
func (v *SetupResponse) GetErnie_checking() SetupErnie_checkingAccount { return v.Ernie_checking }

// GetBert_checking returns SetupResponse.Bert_checking, and is useful for accessing the field via an interface.
func (v *SetupResponse) GetBert_checking() SetupBert_checkingAccount { return v.Bert_checking }

// StatementBalanceClosedBalance includes the requested fields of the GraphQL type Balance.
// The GraphQL type's documentation follows.
//
// Balances are auto-calculated sums of the entries for a given account.
//
// Every balance record maintains a `drBalance` for entries on the debit side of the ledger and a `crBalance` for credit entries.
//
// Additionally, every account has a `normalBalance`, which is equal to `crBalance - drBalance` for credit normal accounts, and `drBalance - crBalance` for debit normal accounts.
//
// Each account can have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.
type StatementBalanceClosedBalance struct {
	// Time of the last change. Especially useful when reviewing the `history`.
	Modified Timestamp `json:"modified"`
	// The balance amounts available by combining the provided layer with all layers above.
	Available StatementBalanceClosedBalanceAvailableBalanceAmount `json:"available"`
	// History of changes to this Balance record.
	// Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
	History StatementBalanceClosedBalanceHistoryBalanceConnection `json:"history"`
}

// GetModified returns StatementBalanceClosedBalance.Modified, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalance) GetModified() Timestamp { return v.Modified }

// GetAvailable returns StatementBalanceClosedBalance.Available, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalance) GetAvailable() StatementBalanceClosedBalanceAvailableBalanceAmount {
	return v.Available
}

// GetHistory returns StatementBalanceClosedBalance.History, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalance) GetHistory() StatementBalanceClosedBalanceHistoryBalanceConnection {
	return v.History
}

// StatementBalanceClosedBalanceAvailableBalanceAmount includes the requested fields of the GraphQL type BalanceAmount.
type StatementBalanceClosedBalanceAvailableBalanceAmount struct {
	// The "normal balance" for an account is different for credit normal and debit normal accounts.
	//
	// For credit normal accounts, the normal balance is equal to `crBalance - drBalance`.
	// For debit normal accounts, the normal balance is the reverse: `drBalance - crBalance`.
	NormalBalance StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney `json:"normalBalance"`
}

// GetNormalBalance returns StatementBalanceClosedBalanceAvailableBalanceAmount.NormalBalance, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceAvailableBalanceAmount) GetNormalBalance() StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney {
	return v.NormalBalance
}

// StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney includes the requested fields of the GraphQL type Money.
// The GraphQL type's documentation follows.
//
// Money type with multi-currency support.
//
// Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.
//
// Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.
//
// | Currency | Units    | Formatted |
// |----------|----------|-----------|
// | USD      | `289.27` | $289.27   |
// | BHD      | `28.927` | 28.927 BD |
// | JPY      | `28927`  | ¥28927    |
type StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney struct {
	Units Decimal `json:"units"`
}

// GetUnits returns StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney.Units, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceAvailableBalanceAmountNormalBalanceMoney) GetUnits() Decimal {
	return v.Units
}

// StatementBalanceClosedBalanceHistoryBalanceConnection includes the requested fields of the GraphQL type BalanceConnection.
// The GraphQL type's documentation follows.
//
// Connection to a list of Balance nodes.
// Access Balance nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
// Use `pageInfo` to paginate responses using the cursors provided.
type StatementBalanceClosedBalanceHistoryBalanceConnection struct {
	Nodes []*StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance `json:"nodes"`
}

// GetNodes returns StatementBalanceClosedBalanceHistoryBalanceConnection.Nodes, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceHistoryBalanceConnection) GetNodes() []*StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance {
	return v.Nodes
}

// StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance includes the requested fields of the GraphQL type Balance.
// The GraphQL type's documentation follows.
//
// Balances are auto-calculated sums of the entries for a given account.
//
// Every balance record maintains a `drBalance` for entries on the debit side of the ledger and a `crBalance` for credit entries.
//
// Additionally, every account has a `normalBalance`, which is equal to `crBalance - drBalance` for credit normal accounts, and `drBalance - crBalance` for debit normal accounts.
//
// Each account can have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.
type StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance struct {
	// Reference to the most recent entry used to calculate the balance.
	Entry StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry `json:"entry"`
}

// GetEntry returns StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance.Entry, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalance) GetEntry() StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry {
	return v.Entry
}

// StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry includes the requested fields of the GraphQL type Entry.
// The GraphQL type's documentation follows.
//
// An entry represents one side of a transaction in a ledger. In other systems, these may be called "ledger lines" or "journal entries".
//
// Entries always have an account, amount, and direction (CREDIT or DEBIT). In addition, Twisp uses the concept of "entry types" to assign every entry to a categorical type.
//
// Twisp enforces double-entry accounting, which in practice means that entries can only be entered in the context of a Transaction. Posting a transaction will create _at least 2_ ledger entries.
type StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry struct {
	// Arbitrary structured data about this entry.
	Metadata *map[string]interface{} `json:"metadata"`
	// Amount of the ledger entry using the currency-supported Money type.
	Amount StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney `json:"amount"`
}

// GetMetadata returns StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry.Metadata, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry) GetMetadata() *map[string]interface{} {
	return v.Metadata
}

// GetAmount returns StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry.Amount, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntry) GetAmount() StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney {
	return v.Amount
}

// StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney includes the requested fields of the GraphQL type Money.
// The GraphQL type's documentation follows.
//
// Money type with multi-currency support.
//
// Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.
//
// Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.
//
// | Currency | Units    | Formatted |
// |----------|----------|-----------|
// | USD      | `289.27` | $289.27   |
// | BHD      | `28.927` | 28.927 BD |
// | JPY      | `28927`  | ¥28927    |
type StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney struct {
	Units Decimal `json:"units"`
}

// GetUnits returns StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney.Units, and is useful for accessing the field via an interface.
func (v *StatementBalanceClosedBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney) GetUnits() Decimal {
	return v.Units
}

// StatementBalanceOpenBalance includes the requested fields of the GraphQL type Balance.
// The GraphQL type's documentation follows.
//
// Balances are auto-calculated sums of the entries for a given account.
//
// Every balance record maintains a `drBalance` for entries on the debit side of the ledger and a `crBalance` for credit entries.
//
// Additionally, every account has a `normalBalance`, which is equal to `crBalance - drBalance` for credit normal accounts, and `drBalance - crBalance` for debit normal accounts.
//
// Each account can have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.
type StatementBalanceOpenBalance struct {
	// Time of the last change. Especially useful when reviewing the `history`.
	Modified Timestamp `json:"modified"`
	// The balance amounts available by combining the provided layer with all layers above.
	Available StatementBalanceOpenBalanceAvailableBalanceAmount `json:"available"`
	// History of changes to this Balance record.
	// Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
	History StatementBalanceOpenBalanceHistoryBalanceConnection `json:"history"`
}

// GetModified returns StatementBalanceOpenBalance.Modified, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalance) GetModified() Timestamp { return v.Modified }

// GetAvailable returns StatementBalanceOpenBalance.Available, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalance) GetAvailable() StatementBalanceOpenBalanceAvailableBalanceAmount {
	return v.Available
}

// GetHistory returns StatementBalanceOpenBalance.History, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalance) GetHistory() StatementBalanceOpenBalanceHistoryBalanceConnection {
	return v.History
}

// StatementBalanceOpenBalanceAvailableBalanceAmount includes the requested fields of the GraphQL type BalanceAmount.
type StatementBalanceOpenBalanceAvailableBalanceAmount struct {
	// The "normal balance" for an account is different for credit normal and debit normal accounts.
	//
	// For credit normal accounts, the normal balance is equal to `crBalance - drBalance`.
	// For debit normal accounts, the normal balance is the reverse: `drBalance - crBalance`.
	NormalBalance StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney `json:"normalBalance"`
}

// GetNormalBalance returns StatementBalanceOpenBalanceAvailableBalanceAmount.NormalBalance, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceAvailableBalanceAmount) GetNormalBalance() StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney {
	return v.NormalBalance
}

// StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney includes the requested fields of the GraphQL type Money.
// The GraphQL type's documentation follows.
//
// Money type with multi-currency support.
//
// Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.
//
// Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.
//
// | Currency | Units    | Formatted |
// |----------|----------|-----------|
// | USD      | `289.27` | $289.27   |
// | BHD      | `28.927` | 28.927 BD |
// | JPY      | `28927`  | ¥28927    |
type StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney struct {
	Units Decimal `json:"units"`
}

// GetUnits returns StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney.Units, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceAvailableBalanceAmountNormalBalanceMoney) GetUnits() Decimal {
	return v.Units
}

// StatementBalanceOpenBalanceHistoryBalanceConnection includes the requested fields of the GraphQL type BalanceConnection.
// The GraphQL type's documentation follows.
//
// Connection to a list of Balance nodes.
// Access Balance nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
// Use `pageInfo` to paginate responses using the cursors provided.
type StatementBalanceOpenBalanceHistoryBalanceConnection struct {
	Nodes []*StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance `json:"nodes"`
}

// GetNodes returns StatementBalanceOpenBalanceHistoryBalanceConnection.Nodes, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceHistoryBalanceConnection) GetNodes() []*StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance {
	return v.Nodes
}

// StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance includes the requested fields of the GraphQL type Balance.
// The GraphQL type's documentation follows.
//
// Balances are auto-calculated sums of the entries for a given account.
//
// Every balance record maintains a `drBalance` for entries on the debit side of the ledger and a `crBalance` for credit entries.
//
// Additionally, every account has a `normalBalance`, which is equal to `crBalance - drBalance` for credit normal accounts, and `drBalance - crBalance` for debit normal accounts.
//
// Each account can have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.
type StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance struct {
	// Reference to the most recent entry used to calculate the balance.
	Entry StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry `json:"entry"`
}

// GetEntry returns StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance.Entry, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalance) GetEntry() StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry {
	return v.Entry
}

// StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry includes the requested fields of the GraphQL type Entry.
// The GraphQL type's documentation follows.
//
// An entry represents one side of a transaction in a ledger. In other systems, these may be called "ledger lines" or "journal entries".
//
// Entries always have an account, amount, and direction (CREDIT or DEBIT). In addition, Twisp uses the concept of "entry types" to assign every entry to a categorical type.
//
// Twisp enforces double-entry accounting, which in practice means that entries can only be entered in the context of a Transaction. Posting a transaction will create _at least 2_ ledger entries.
type StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry struct {
	// Arbitrary structured data about this entry.
	Metadata *map[string]interface{} `json:"metadata"`
	// Amount of the ledger entry using the currency-supported Money type.
	Amount StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney `json:"amount"`
}

// GetMetadata returns StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry.Metadata, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry) GetMetadata() *map[string]interface{} {
	return v.Metadata
}

// GetAmount returns StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry.Amount, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntry) GetAmount() StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney {
	return v.Amount
}

// StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney includes the requested fields of the GraphQL type Money.
// The GraphQL type's documentation follows.
//
// Money type with multi-currency support.
//
// Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.
//
// Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.
//
// | Currency | Units    | Formatted |
// |----------|----------|-----------|
// | USD      | `289.27` | $289.27   |
// | BHD      | `28.927` | 28.927 BD |
// | JPY      | `28927`  | ¥28927    |
type StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney struct {
	Units Decimal `json:"units"`
}

// GetUnits returns StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney.Units, and is useful for accessing the field via an interface.
func (v *StatementBalanceOpenBalanceHistoryBalanceConnectionNodesBalanceEntryAmountMoney) GetUnits() Decimal {
	return v.Units
}

// StatementBalanceResponse is returned by StatementBalance on success.
type StatementBalanceResponse struct {
	// Get a balance for an account.
	Open *StatementBalanceOpenBalance `json:"open"`
	// Get a balance for an account.
	Closed *StatementBalanceClosedBalance `json:"closed"`
}

// GetOpen returns StatementBalanceResponse.Open, and is useful for accessing the field via an interface.
func (v *StatementBalanceResponse) GetOpen() *StatementBalanceOpenBalance { return v.Open }

// GetClosed returns StatementBalanceResponse.Closed, and is useful for accessing the field via an interface.
func (v *StatementBalanceResponse) GetClosed() *StatementBalanceClosedBalance { return v.Closed }

// __ActivityQueryInput is used internally by genqlient
type __ActivityQueryInput struct {
	JournalId *string `json:"journalId"`
	AccountId *string `json:"accountId"`
	Period    *string `json:"period"`
}

// GetJournalId returns __ActivityQueryInput.JournalId, and is useful for accessing the field via an interface.
func (v *__ActivityQueryInput) GetJournalId() *string { return v.JournalId }

// GetAccountId returns __ActivityQueryInput.AccountId, and is useful for accessing the field via an interface.
func (v *__ActivityQueryInput) GetAccountId() *string { return v.AccountId }

// GetPeriod returns __ActivityQueryInput.Period, and is useful for accessing the field via an interface.
func (v *__ActivityQueryInput) GetPeriod() *string { return v.Period }

// __PostTransactionInput is used internally by genqlient
type __PostTransactionInput struct {
	TransactionId uuid.UUID `json:"transactionId"`
	Effective     Date      `json:"effective"`
}

// GetTransactionId returns __PostTransactionInput.TransactionId, and is useful for accessing the field via an interface.
func (v *__PostTransactionInput) GetTransactionId() uuid.UUID { return v.TransactionId }

// GetEffective returns __PostTransactionInput.Effective, and is useful for accessing the field via an interface.
func (v *__PostTransactionInput) GetEffective() Date { return v.Effective }

// __PostTransactionWithStatementDateInput is used internally by genqlient
type __PostTransactionWithStatementDateInput struct {
	TransactionId uuid.UUID `json:"transactionId"`
	Effective     Date      `json:"effective"`
	StatementDate Date      `json:"statementDate"`
}

// GetTransactionId returns __PostTransactionWithStatementDateInput.TransactionId, and is useful for accessing the field via an interface.
func (v *__PostTransactionWithStatementDateInput) GetTransactionId() uuid.UUID {
	return v.TransactionId
}

// GetEffective returns __PostTransactionWithStatementDateInput.Effective, and is useful for accessing the field via an interface.
func (v *__PostTransactionWithStatementDateInput) GetEffective() Date { return v.Effective }

// GetStatementDate returns __PostTransactionWithStatementDateInput.StatementDate, and is useful for accessing the field via an interface.
func (v *__PostTransactionWithStatementDateInput) GetStatementDate() Date { return v.StatementDate }

// __SetupInput is used internally by genqlient
type __SetupInput struct {
	JournalId  uuid.UUID `json:"journalId"`
	TranCodeId uuid.UUID `json:"tranCodeId"`
	Account1Id uuid.UUID `json:"account1Id"`
	Account2Id uuid.UUID `json:"account2Id"`
}

// GetJournalId returns __SetupInput.JournalId, and is useful for accessing the field via an interface.
func (v *__SetupInput) GetJournalId() uuid.UUID { return v.JournalId }

// GetTranCodeId returns __SetupInput.TranCodeId, and is useful for accessing the field via an interface.
func (v *__SetupInput) GetTranCodeId() uuid.UUID { return v.TranCodeId }

// GetAccount1Id returns __SetupInput.Account1Id, and is useful for accessing the field via an interface.
func (v *__SetupInput) GetAccount1Id() uuid.UUID { return v.Account1Id }

// GetAccount2Id returns __SetupInput.Account2Id, and is useful for accessing the field via an interface.
func (v *__SetupInput) GetAccount2Id() uuid.UUID { return v.Account2Id }

// __StatementBalanceInput is used internally by genqlient
type __StatementBalanceInput struct {
	AccountID             uuid.UUID `json:"accountID"`
	JournalID             uuid.UUID `json:"journalID"`
	OpenDate              Date      `json:"openDate"`
	CloseDate             Date      `json:"closeDate"`
	PriorPeriodCloseStamp string    `json:"priorPeriodCloseStamp"`
	ThisPeriodCloseStamp  string    `json:"thisPeriodCloseStamp"`
}

// GetAccountID returns __StatementBalanceInput.AccountID, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetAccountID() uuid.UUID { return v.AccountID }

// GetJournalID returns __StatementBalanceInput.JournalID, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetJournalID() uuid.UUID { return v.JournalID }

// GetOpenDate returns __StatementBalanceInput.OpenDate, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetOpenDate() Date { return v.OpenDate }

// GetCloseDate returns __StatementBalanceInput.CloseDate, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetCloseDate() Date { return v.CloseDate }

// GetPriorPeriodCloseStamp returns __StatementBalanceInput.PriorPeriodCloseStamp, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetPriorPeriodCloseStamp() string { return v.PriorPeriodCloseStamp }

// GetThisPeriodCloseStamp returns __StatementBalanceInput.ThisPeriodCloseStamp, and is useful for accessing the field via an interface.
func (v *__StatementBalanceInput) GetThisPeriodCloseStamp() string { return v.ThisPeriodCloseStamp }

// The query executed by ActivityQuery.
const ActivityQuery_Operation = `
query ActivityQuery ($journalId: String, $accountId: String, $period: String) {
	entries(index: {name:CUSTOM}, where: {custom:{index:"activity",partition:[{alias:"journalId",value:{eq:$journalId}},{alias:"accountId",value:{eq:$accountId}},{alias:"settled",value:{eq:"true"}},{alias:"period",value:{eq:$period}}],sort:[]}}, first: 100) {
		nodes {
			metadata
			amount {
				units
			}
		}
	}
}
`

func ActivityQuery(
	ctx_ context.Context,
	client_ graphql.Client,
	journalId *string,
	accountId *string,
	period *string,
) (data_ *ActivityQueryResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "ActivityQuery",
		Query:  ActivityQuery_Operation,
		Variables: &__ActivityQueryInput{
			JournalId: journalId,
			AccountId: accountId,
			Period:    period,
		},
	}

	data_ = &ActivityQueryResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

// The mutation executed by CreateActivityIndex.
const CreateActivityIndex_Operation = `
mutation CreateActivityIndex {
	schema {
		createIndex(input: {name:"activity",on:Entry,partition:[{alias:"journalId",value:"document.journal_id"},{alias:"accountId",value:"document.parent_account_ids+[document.account_id]"},{alias:"settled",value:"string(bool(document.layer == 0))"},{alias:"period",value:"string(date(document.?metadata.?statementDate.orValue(document.?metadata.?effective.orValue(document.created)))).take(7)",type:STRING}],sort:[{alias:"created",value:"document.created",sort:DESC}],constraints:{isNotVoidEntry:"!document.is_void_entry",isNotVoidedEntry:"!document.is_voided_entry"}}) {
			on
		}
	}
}
`

func CreateActivityIndex(
	ctx_ context.Context,
	client_ graphql.Client,
) (data_ *CreateActivityIndexResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "CreateActivityIndex",
		Query:  CreateActivityIndex_Operation,
	}

	data_ = &CreateActivityIndexResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

// The mutation executed by PostTransaction.
const PostTransaction_Operation = `
mutation PostTransaction ($transactionId: UUID!, $effective: Date!) {
	postTransaction(input: {transactionId:$transactionId,tranCode:"SIMPLE",params:{account1:"1fd1dd3e-33fe-4ef5-9d58-676ef8d306b5",account2:"6c6affb0-5cf5-402b-8d84-01bfc1624a2c",effective:$effective,amount:"1.00"}}) {
		transactionId
		created
	}
}
`

func PostTransaction(
	ctx_ context.Context,
	client_ graphql.Client,
	transactionId uuid.UUID,
	effective Date,
) (data_ *PostTransactionResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "PostTransaction",
		Query:  PostTransaction_Operation,
		Variables: &__PostTransactionInput{
			TransactionId: transactionId,
			Effective:     effective,
		},
	}

	data_ = &PostTransactionResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

// The mutation executed by PostTransactionWithStatementDate.
const PostTransactionWithStatementDate_Operation = `
mutation PostTransactionWithStatementDate ($transactionId: UUID!, $effective: Date!, $statementDate: Date!) {
	postTransaction(input: {transactionId:$transactionId,tranCode:"SIMPLE",params:{account1:"1fd1dd3e-33fe-4ef5-9d58-676ef8d306b5",account2:"6c6affb0-5cf5-402b-8d84-01bfc1624a2c",effective:$effective,statementDate:$statementDate,amount:"5.00"}}) {
		transactionId
		created
	}
}
`

func PostTransactionWithStatementDate(
	ctx_ context.Context,
	client_ graphql.Client,
	transactionId uuid.UUID,
	effective Date,
	statementDate Date,
) (data_ *PostTransactionWithStatementDateResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "PostTransactionWithStatementDate",
		Query:  PostTransactionWithStatementDate_Operation,
		Variables: &__PostTransactionWithStatementDateInput{
			TransactionId: transactionId,
			Effective:     effective,
			StatementDate: statementDate,
		},
	}

	data_ = &PostTransactionWithStatementDateResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

// The mutation executed by Setup.
const Setup_Operation = `
mutation Setup ($journalId: UUID!, $tranCodeId: UUID!, $account1Id: UUID!, $account2Id: UUID!) {
	createJournal(input: {journalId:$journalId,name:"Sample",code:"SAMPLE",config:{enableEffectiveBalances:true}}) {
		journalId
	}
	createTranCode(input: {tranCodeId:$tranCodeId,code:"SIMPLE",description:"simple tran code",params:[{name:"account1",type:UUID,description:"Acct 1"},{name:"account2",type:UUID,description:"Acct 2"},{name:"amount",type:DECIMAL,description:"Decimal amount"},{name:"effective",type:DATE,description:"effective"},{name:"statementDate",type:DATE,description:"statement dates for backdated transactions",default:"1970-01-01"},{name:"currency",type:STRING,description:"Currency",default:"USD"}],vars:{statementDate:"params.statementDate == date('1970-01-01') ? string(params.effective) : string(params.statementDate)"},transaction:{effective:"params.effective",journalId:"uuid('b125f5a0-e803-11f0-a078-069b540ea27c')"},entries:[{accountId:"params.account1",units:"params.amount",currency:"params.currency",entryType:"'SIMPLE_CR'",direction:"CREDIT",layer:"SETTLED",metadata:"{ 'effective':string(params.effective), 'statementDate': vars.statementDate }"},{accountId:"params.account2",units:"params.amount",currency:"params.currency",entryType:"'SIMPLE_DR'",direction:"DEBIT",layer:"SETTLED",metadata:"{ 'effective':string(params.effective), 'statementDate': vars.statementDate }"}]}) {
		tranCodeId
	}
	ernie_checking: createAccount(input: {accountId:$account1Id,name:"Ernie Bishop - Checking",code:"ERNIE.CHECKING",description:"Ernie's checking account",normalBalanceType:CREDIT}) {
		accountId
		name
	}
	bert_checking: createAccount(input: {accountId:$account2Id,name:"Bert - Checking",code:"BERT.CHECKING",description:"Bert's checking account",normalBalanceType:CREDIT}) {
		accountId
		name
	}
}
`

func Setup(
	ctx_ context.Context,
	client_ graphql.Client,
	journalId uuid.UUID,
	tranCodeId uuid.UUID,
	account1Id uuid.UUID,
	account2Id uuid.UUID,
) (data_ *SetupResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "Setup",
		Query:  Setup_Operation,
		Variables: &__SetupInput{
			JournalId:  journalId,
			TranCodeId: tranCodeId,
			Account1Id: account1Id,
			Account2Id: account2Id,
		},
	}

	data_ = &SetupResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}

// The query executed by StatementBalance.
const StatementBalance_Operation = `
query StatementBalance ($accountID: UUID!, $journalID: UUID!, $openDate: Date!, $closeDate: Date!, $priorPeriodCloseStamp: String!, $thisPeriodCloseStamp: String!) {
	open: balance(accountId: $accountID, journalId: $journalID, effective: {cumulative:$openDate,where:{modified:{lt:$priorPeriodCloseStamp}}}, type: PREPARED) {
		modified
		available(layer: SETTLED) {
			normalBalance {
				units
			}
		}
		history(first: 5) {
			nodes {
				entry {
					metadata
					amount {
						units
					}
				}
			}
		}
	}
	closed: balance(accountId: $accountID, journalId: $journalID, effective: {cumulative:$closeDate,where:{modified:{lt:$thisPeriodCloseStamp}}}, type: PREPARED) {
		modified
		available(layer: SETTLED) {
			normalBalance {
				units
			}
		}
		history(first: 5) {
			nodes {
				entry {
					metadata
					amount {
						units
					}
				}
			}
		}
	}
}
`

func StatementBalance(
	ctx_ context.Context,
	client_ graphql.Client,
	accountID uuid.UUID,
	journalID uuid.UUID,
	openDate Date,
	closeDate Date,
	priorPeriodCloseStamp string,
	thisPeriodCloseStamp string,
) (data_ *StatementBalanceResponse, err_ error) {
	req_ := &graphql.Request{
		OpName: "StatementBalance",
		Query:  StatementBalance_Operation,
		Variables: &__StatementBalanceInput{
			AccountID:             accountID,
			JournalID:             journalID,
			OpenDate:              openDate,
			CloseDate:             closeDate,
			PriorPeriodCloseStamp: priorPeriodCloseStamp,
			ThisPeriodCloseStamp:  thisPeriodCloseStamp,
		},
	}

	data_ = &StatementBalanceResponse{}
	resp_ := &graphql.Response{Data: data_}

	err_ = client_.MakeRequest(
		ctx_,
		req_,
		resp_,
	)

	return data_, err_
}
