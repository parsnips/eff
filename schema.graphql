schema {
  query: Query
  mutation: Mutation
}

directive @goModel(
  model: String
  models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

"""
Denotes that the variable definition is resolved via a CEL Expression.

The default value provided to the string is the CEL expression.
And the cel value must resolve/convert to the graphql type indicated by the variable.

@example(`$someVariable: String = "string('hello world')" @cel`)
"""
directive @cel on VARIABLE_DEFINITION

directive @export(as: String!) on FIELD

"""
Allows to dryRun a mutation without committing the data.
"""
directive @dryRun on MUTATION

"""
Twisp will retry retriable errors for up to duration automatically.

Uses a golang duration string. If the value is less than or equal to zero, no retries performed.

@example(`@retry(for:"30s")`)
"""
directive @retry(for: String! = "30s") on MUTATION | QUERY

"""
Sets the transaction isolation level for the operation.

@example(`@tx(isolation: SERIALIZABLE)`)
"""
directive @tx(isolation: TxIsolation = SNAPSHOT) on MUTATION | QUERY

"The generic Node interface. All first-class entities in the API implement this interface."
interface Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  See: https://graphql.org/learn/global-object-identification/
  """
  id: ID!
}

# Enable base-level queries once we have fields to expose here.
type Query {
  node(id: ID!): Node
}

type Mutation {
  "Evaluate a CEL (common expression language) expression using Twisp's calculation engine. Returns a String representation of the evaluated result."
  evaluate(expressions: ExpressionNestedMap!, document: Value): Value!
}

"Date in YYYY-MM-DD format. @example('2022-08-18')"
scalar Date

"Decimal is a fixed-precision data type supporting exact representation of numeric values. @example(105.92851)"
scalar Decimal

"""
[RFC3339-compliant](https://www.rfc-editor.org/rfc/rfc3339) UTC timestamp.
@example('2022-04-27T10:50:00.000Z')
"""
scalar Timestamp

"Uint8Array is a []uint8 of big-endian encoded binary data"
scalar Uint8Array

"""
Interpolated string expression. Values within `{{}}` are evaluated as a CEL expression.

Examples:
- `Current time: {{time.Now()}}` => `"Current time: 2022-04-27T10:50:00.000Z"`
- `Raw String` => `"Raw String"`
- `{{uuid.New()}}` => `"9dd984db-78d8-420f-9380-80e3cf36fe75"`
"""
scalar InterpolatedExpression

"""
A literal CEL expression to be evaluated.
"""
scalar Expression

"""
A map of literal CEL expressions to be evaluated in a shared context
Ex: {
  "two": "this.one + 1",
  "one": "2 - 1",
  "sqrt2": "math.Sqrt(double(2))",
  "now": "time.Now()"
}
"""
scalar ExpressionMap

"""
A nested map of literal CEL expressions to be evaluated in a shared context
Ex: {
  "two": "this.one + 1",
  "one": "2 - 1",
  "sqrt2": "math.Sqrt(double(2))",
  "now": "time.Now()",
  "obj": {
     "foo": "'bar'"
  }
}
"""
scalar ExpressionNestedMap

"String value for an entry type. @example('ACH_CR')"
scalar EntryType

"""
JSON object.

@example(`{ "counts": 12, "name": "Metric A" }`)
"""
scalar JSON

"""
Value object. Similar to the JSON object with support for type coersion

@example(`{ "int": 12, "float": 1.732, "uuid": "D3DC5ED3-23D0-4924-BAE1-9AA026BACE09"}`)
"""
scalar Value

"""
128-bit universally unique identifier (UUID). Used for most ID fields on records.
@example('3ea12e45-7df2-4293-9434-feb792affc91')
"""
scalar UUID

"""
Account status determines whether the account is in active use or closed (locked). By default, all accounts are `ACTIVE`.

When account is `LOCKED`, it cannot be changed and any attempt to write a ledger entry to this account will raise an error.
"""
enum AccountStatus {
  "ACTIVE = Account is open for posting."
  ACTIVE
  "LOCKED = Account is locked and will block posting."
  LOCKED
  "INACTIVE = Account is open for posting but will be LOCKED soon."
  INACTIVE
}

"""
All operations in Twisp are **strongly consistent** and
transactionally isolated. Both concurrent and non-concurrent enabled
accounts provide the same strong consistency guarantee on balances,
but concurrent enabled accounts can adjust their balance isolation
levels and latency characteristics according to different user needs.
"""
enum BalanceType {
  """
  Return the latest calculated balance record for the account. This
  balance may be slightly stale but offers the lowest latency.
  """
  FINAL
  """
  Return the latest calculated balance record plus any committed, but
  not yet FINAL, entries. This balance is transactionally consistent
  for the current snapshot and guaranteed to eventually match a FINAL
  balance record.
  """
  PREPARED
  """
  Return the latest calculated balance record plus any committed, but
  not yet FINAL, entries along with all in-flight uncommitted
  entries. This balance is provisional since uncommitted entries are
  not guaranteed to commit.
  """
  PROVISIONAL
}

"Debit or credit? Sometimes these are abbreviated to DR and CR."
enum DebitOrCredit {
  DEBIT
  CREDIT
}

"""
The ledger can apply a entries to one of three layers: SETTLED, PENDING, and ENCUMBRANCE.

The SETTLED layer is what is actually fully settled.

The PENDING layer is what's settled but also includes holds and pending charges. This can be used to verify the account will have enough funds after the holds and pending transactions have cleared.

The ENCUMBRANCE layer allows us to add future transactions that are scheduled and also goals or budgeting tools to set money aside in the account.
"""
enum Layer {
  SETTLED
  PENDING
  ENCUMBRANCE
}

"Data type of a parameter."
enum ParamDataType {
  STRING
  INTEGER
  DECIMAL
  BOOLEAN
  UUID
  DATE
  TIMESTAMP
  JSON
}

enum IndexDataType {
  INT
  UINT
  DOUBLE
  BOOL
  STRING
  BYTES
  DURATION
  TIMESTAMP
  UUID
  DATE
  MONEY
  DECIMAL
}

"`ASC` (ascending) or `DESC` (descending)."
enum SortOrder {
  ASC
  DESC
}

"""
Transaction isolation level.

Different isolation levels provide different guarantees about data visibility and consistency.
"""
enum TxIsolation {
  "Read committed isolation - allows reading only committed data"
  READ_COMMITTED
  "Snapshot isolation - provides a consistent snapshot view of the database"
  SNAPSHOT
  "Repeatable read isolation - prevents non-repeatable reads"
  REPEATABLE_READ
  "Serializable isolation - strictest isolation level"
  SERIALIZABLE
}

"""
Record status. All records are `ACTIVE` by default.

To avoid rewriting accounting history, most records are not deleted but simply marked `LOCKED`, indicating that they should not be used.
"""
enum Status {
  ACTIVE
  LOCKED
  INACTIVE
}

input DimensionFilterValue {
  eq: JSON
  like: JSON
  lt: JSON
  lte: JSON
  gt: JSON
  gte: JSON
  between: DimensionBetween
}

input DimensionBetween {
  begin: JSON
  end: JSON
}

"""
Conditional logic by which to apply a filter on a query.

Each FilterValue object must contain just one key/value pair.

Valid: `{ eq: "123" }`\
Invalid: `{ eq: "123", gt: "100" }`
"""
input FilterValue {
  eq: String
  like: String
  lt: String
  lte: String
  gt: String
  gte: String
  all: Boolean
  between: Between
  # Not yet implemented
  # in: [String]
  # has: String
  # null: String
}

input Between {
  begin: String
  end: String
}

"""
SearchFilter supports Opensearch Query DSL under the "query" key

See https://opensearch.org/docs/latest/query-dsl/ for more information on how to construct these queries.
"""
input SearchFilter {
  "The `name` of the search index to use."
  index: String!
  "The Opensearch DSL query to use."
  query: JSON!
  "The open search DSL sort to use."
  sort: [JSON!]
}

type PageInfo {
  "True if there are nodes in the connection before the current page / start cursor."
  hasPreviousPage: Boolean!
  "True if there are nodes in the connection after the current page / end cursor."
  hasNextPage: Boolean!
  "Query cursor for the first node in the current page."
  startCursor: String
  "Query cursor for the last node in the current page."
  endCursor: String
}

"Connection types must contain a `pageInfo` field as well as `nodes` and `edges`."
interface Connection {
  pageInfo: PageInfo!
}

type DocumentElement {
  """
  Alias for this element.
  """
  alias: String!
  """
  The CEL expression for the value of this document element.
  """
  value: Expression!
  """
  The type this document element resolves to.
  """
  type: CelType!
  """
  If `true` resolves the type as a `[type]`
  """
  listOfType: Boolean!
}

input DocumentElementInput {
  """
  Alias for this element.
  """
  alias: String!
  """
  The CEL expression for the value of this document element.

  @example("context.source.account_id")
  """
  value: Expression!
  """
  The type this document element resolves to.
  """
  type: CelType!
  """
  If `true` resolves the type as a list of `type` (i.e. `[type]`)
  """
  listOfType: Boolean! = false
}

enum CelType {
  """
  A json object
  """
  JSON
  """
  RFC-3339 formatted timestamp.
  """
  Timestamp
  """
  Golang formatted duration string.
  """
  Duration
  """
  Signed 64 bit floating point.
  """
  Double
  """
  128-Bit fixed precision decimal.
  """
  Decimal
  """
  UTF-8 encoded string.
  """
  String
  """
  Boolean
  """
  Bool
  """
  Signed 64-bit integer
  """
  Int
  """
  Unsigned 64-bit integer
  """
  UInt
  """
  Base64 encoded bytestring.
  """
  Bytes
  """
  UUID supporting v1-8
  """
  UUID
}

union DatabaseEntity = Account | AccountSet | Balance | Entry | Transaction | TranCode

extend type Query {
  "Get a single account by its `accountId`."
  account(
    """
    Unique identifier. @example("3ea12e45-7df2-4293-9434-feb792affc91")
    """
    id: UUID!
  ): Account

  "Select one or more accounts. Specify the index to use and apply filters to your query."
  accounts(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: AccountIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: AccountFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountConnection!
}

extend type Mutation {
  "Create a new account."
  createAccount("Fields to create a new account." input: AccountInput!): Account!

  "Update fields on an existing account. To ensure data integrity, only a subset of fields are allowed."
  updateAccount(
    "Unique identifier."
    id: UUID!
    "Fields to update."
    input: AccountUpdateInput!
  ): Account!

  "Delete account moves the account state to `LOCKED`. When an account is in LOCKED, prevents entries from being posted to it."
  deleteAccount("Unique identifier." id: UUID!): Account
}

"""
Accounts model all of the economic activity that your ledger provides.

The chart of accounts is the basis for creating balance sheets, P&L reports, and for understanding the balances for the customer and business entities your business services.

Accounts can be organized into sets with the AccountSet type. Hierarchical tree structures which roll up balances across many accounts can be modeled by nesting sets within other sets.
"""
type Account implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `ac:<key>` where `key` is `base64(json({ 1: accountId }))`.
  """
  id: ID!

  "Unique identifier for the account."
  accountId: UUID!

  "Allows specifying a unique external ID associated with this account."
  externalId: String!

  """
  Account name. @example("Bill Pay Settlement") @example("Courtesy Credit")
  """
  name: String!

  """
  Shorthand code for the account, often an abbreviated version of the account name.
  Example: 'ACH_RECON' for an account named 'ACH Reconciliation'.
  """
  code: String!

  "Description of the account."
  description: String!

  "Current status for the account."
  status: AccountStatus!

  """
  Flag indicating whether this account uses a "debit normal" or a "credit normal" balance.

  In double-entry accounting, accounts with a debit normal balance use the balance calculation `balance = debits - credits`. This is used for asset and expense account types.

  Accounts with a credit normal balance, in contrast, calculate their balance with the equation `balance = credits - debits`. This is the default type for liabilities, equity, and revenue account types.
  """
  normalBalanceType: DebitOrCredit!

  "Metadata attached to this account."
  metadata: JSON

  "System config for this account."
  config: AccountConfig!

  "Date and time when the account was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this account. Previous versions are tracked in `history`."
  version: Int!

  _recordId: UUID!

  """
  Reference to the balances for this account.

  Accounts have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.

  Each balance reflects the current total debits and credits for all entries in this account within the specified journal and currency.
  """
  balances(
    """
    Select from a list of pre-defined indexes. Defaults to `BalanceIndex.ACCOUNT_ID`.
    """
    index: BalanceIndexInput
    "Query conditions to filter the balances returned."
    where: BalanceFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): BalanceConnection! @goField(forceResolver: true)

  """
  Reference to the balance for a specific journal and currency (defaults to "USD").
  """
  balance(
    "ID of the journal for the balance. If omitted, the default journal will be used."
    journalId: UUID
    "Currency of the balance."
    currency: CurrencyCode = "USD"
    "If provided, look up based on calculation id and dimensions for calculation."
    calculationId: UUID
    "If provided, look up based on calculation id and dimensions for calculation. The values in this should be string representation of values."
    dimension: JSON
    "If enabled and provided, look up balances based on effective date."
    effective: Effective
    "If concurrent enabled, compute balance with all visible transactions."
    materialize: Boolean
    "If concurrent enabled, the isolation level of the balance returned."
    type: BalanceType
  ): Balance @goField(forceResolver: true)

  "All ledger entries associated with this account."
  entries(
    "Query conditions to filter the entries returned."
    where: AccountEntriesFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EntryConnection! @goField(forceResolver: true)

  """
  Accounts can be organized into sets. Each account can belong to zero or multiple account sets.
  """
  sets(
    "Query conditions to filter the account sets returned."
    where: AccountSetFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountSetConnection! @goField(forceResolver: true)

  """
  History of changes to this Account record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountConnection! @goField(forceResolver: true)

  velocity(
    """
    The window of the balance to look up. If
    `velocityLimitId` not provided, will look up
    all velocity limits that support the defined
    window.
    @example({year: "2022", month:"9"})
    """
    window: JSON!
    "The currency for the velocity to look up."
    currency: CurrencyCode! = "USD"
    "If provided, retrieve this specific velocity limit."
    velocityLimitId: UUID
    "If provided, retrieve from specified journal. Otherwise will use default."
    journalId: UUID
  ): [VelocityBalance] @goField(forceResolver: true)

  "Set of controls attached to this account."
  controls(
    first:Int!
    after: String! = ""
  ): ResolvedVelocityControlConnection! @goField(forceResolver: true)

  """
  Retrieve the calculations that are explicitly attached to this account.
  """
  calculations(
    "Defaults to the default journal."
    journalId:UUID
  ): [Calculation!]! @goField(forceResolver: true)
}

"System configuration for an account."
type AccountConfig {
  """
  When `true`, allow concurrent posting to the account.
  See `BalanceType` for balance retrieval options available for concurrent-enabled accounts.
  Defaults to `false`.
  """
  enableConcurrentPosting: Boolean

  """
  When `true`, indicates this account is an underlying account for an account set.
  """
  isAccountSet: Boolean
}

"""
Connection to a list of Account nodes.
Access Account nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type AccountConnection implements Connection {
  nodes: [Account]!
  edges: [AccountConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Account nodes.
They contain a reference to the Account node and metadata like the `cursor` position for the edge.
"""
type AccountConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Account node at this edge."
  node: Account
}

"Specify the pre-defined AccountIndex and sort order to use in a query."
input AccountIndexInput {
  name: AccountIndex!
  sort: SortOrder
}

"Indexes for querying Accounts. To optimize query performance and apply desired filters, choose the appropriate index."
enum AccountIndex {
  "Index by `accountId` field. Must supply an `accountId: { eq: <id> }` filter to the `where` object."
  ACCOUNT_ID
  "Index by `name` field. Use to apply query filters on the value of `name`."
  NAME
  "Index by `code` field. Use to apply query filters on the value of `code`."
  CODE
  "Index by `status` field. Use to apply query filters on the value of `status`."
  STATUS
  "Index by `externalId` field. Must supply an `externalId: { eq: <id> }` filter to the `where` object."
  EXTERNAL_ID
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
  "Index by `code` field. Must supply an `codeUnique: { eq: <id> }` filter to the `where` object."
  CODE_UNIQUE
}

"""
Filter conditions to apply to an account query.
Filters are only applied if the field is used by the specified index.
"""
input AccountFilterInput {
  "Filter on the `accountId` field. Required when using index `AccountIndex.ACCOUNT_ID`."
  accountId: FilterValue
  "Filter on the `externalId` field. Required when using index `AccountIndex.EXTERNAL_ID`."
  externalId: FilterValue
  "Filter on the `name` field. Only available when using index `AccountIndex.NAME`."
  name: FilterValue
  "Filter on the `code` field. Only available when using index `AccountIndex.CODE`."
  code: FilterValue
  "Filter on the `status` field. Only available when using index `AccountIndex.STATUS`."
  status: FilterValue
  "Filter conditions for a custom index. Only available when using index `AccountIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `AccountIndex.SEARCH`."
  search: SearchFilter
  "Filter on the `code` field. Required when using index `AccountIndex.CODE_UNIQUE`."
  codeUnique: FilterValue
}

"Fields to create a new account."
input AccountInput {
  "Unique identifier for the account."
  accountId: UUID!
  "Allows specifying a unique external ID associated with this account."
  externalId: String
  "Shorthand code for the account."
  code: String!
  "Account name."
  name: String!
  "Determines whether account should use a debit- or credit-normal balance."
  normalBalanceType: DebitOrCredit! = CREDIT
  "IDs of AccountSets to add this account to."
  accountSetIds: [UUID]
  "Description of the account."
  description: String
  "Current status for the account."
  status: Status! = ACTIVE
  "Metadata attached to this account."
  metadata: JSON
  "System config for the account."
  config: AccountConfigInput
}

"Fields to create a system configuration for an account."
input AccountConfigInput {
  """
  When `true`, allow concurrent posting to the account.
  See `BalanceType` for balance retrieval options available for concurrent-enabled accounts.
  Defaults to `false`.
  """
  enableConcurrentPosting: Boolean
  """
  When `true` use an upsert on the accountId index to upsert and avoid unique constraint violation.

  If account already created, the existing account is unchanged.
  """
  upsert: Boolean
}

"Account fields to update."
input AccountUpdateInput {
  "Allows specifying a unique external ID associated with this account."
  externalId: String
  "Shorthand code for the account."
  code: String
  "Account name."
  name: String
  "Determines whether account should use a debit- or credit-normal balance."
  normalBalanceType: DebitOrCredit
  "Description of the account."
  description: String
  "Current status for the account."
  status: Status
  "Metadata attached to this account."
  metadata: JSON
  "System config for the account."
  config: AccountConfigInput
}

"""
Filter conditions for entries on an Account.
Since accountId is already known from the parent Account, only journalId and currency filtering is needed.
"""
input AccountEntriesFilterInput {
  "Filter by journal ID. If omitted, entries from all journals are returned."
  journalId: FilterValue
  "Filter by currency. Defaults to USD if not specified."
  currency: FilterValue
}

extend type Query {
  "Get a single account set by its `accountSetId`."
  accountSet("Unique identifier." id: UUID!): AccountSet

  "Select one or more account sets. Specify the index to use and apply filters to your query."
  accountSets(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: AccountSetIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: AccountSetFilterInput
    "Number of sets to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve sets. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountSetConnection! @goField(forceResolver: true)
}

extend type Mutation {
  "Create a new account set."
  createAccountSet("Fields to create a new account set." input: AccountSetInput!): AccountSet!

  "Update fields on an existing account set. To ensure data integrity, only a subset of fields are allowed."
  updateAccountSet(
    "Unique identifier."
    id: UUID!
    "Fields to update."
    input: AccountSetUpdateInput!
  ): AccountSet!

  "Add a new member to a set. Members can be an Account or another AccountSet."
  addToAccountSet(
    "Unique identifier for set."
    id: UUID!
    "Account or AccountSet to add as a member of this set."
    member: AccountSetMemberInput!
  ): AccountSet!

  "Remove a member from a set."
  removeFromAccountSet(
    "Unique identifier for set."
    id: UUID!
    "Account or AccountSet to add as a member of this set."
    member: AccountSetMemberInput!
  ): AccountSet!

  "Delete an account set."
  deleteAccountSet("Unique identifier." id: UUID!): AccountSet
}

"""
A set of accounts.

Account sets contain _members_ which can include accounts as well as other account sets.

Every account set has multiple _balances_ which represent the sum of all balances of member accounts and member account sets. Like balances for accounts, account set balances are computed for every currency used by the entries posted to accounts in a set and all of its sub-sets.

Because account sets are tied to a specific journal, they only compute balances using entries posted to their journal.
"""
type AccountSet implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `as:<key>` where `key` is `base64(json({ 1: accountSetId }))`.
  """
  id: ID!

  "Unique identifier for the set."
  accountSetId: UUID!

  """
  The journal for the set.
  Account sets are confined to a single journal and roll up balances for entries on their journal. Account sets can only contain other sets using the same journal.
  """
  journalId: UUID!

  "Name for the set."
  name: String!

  "code for the account set. Unique value."
  code: String!

  "Description of the account set."
  description: String!

  "Metadata attached to this account set."
  metadata: JSON

  "System config for this account set."
  config: AccountSetConfig!

  """
  Indicates whether this account set uses a "debit normal" or a "credit normal" balance.

  In double-entry accounting, a debit normal balance uses the calculation `balance = debits - credits`.

  A credit normal balance, in contrast, is calculated with the equation `balance = credits - debits`.
  """
  normalBalanceType: DebitOrCredit!

  "Date and time when the account set was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this account set. Previous versions are tracked in `history`."
  version: Int!

  _accountId: UUID!
  _recordId: UUID!

  """
  Reference to the balance for a specific currency (defaults to "USD").
  """
  balance(
    "Currency of the balance."
    currency: CurrencyCode! = "USD"
    "If provided, look up based on calculation id and dimensions for calculation."
    calculationId: UUID
    "If provided, look up based on calculation id and dimensions for calculation. The values in this should be string representation of values."
    dimension: JSON
    "When provided use effective balance."
    effective: Effective
    "If concurrent enabled, compute balance with all visible transactions."
    materialize: Boolean
    "If concurrent enabled, the isolation level of the balance returned."
    type: BalanceType
  ): Balance @goField(forceResolver: true)

  """
  Reference to the balances for this account set.

  Each balance reflects the current sum of debits and credits for all entries on accounts in this set and all accounts in any sub-sets, on the current layer and all layers above.

  Because account sets are tied to a specific journal, they only compute balances using entries posted to their journal.
  """
  balances(
    """
    Select from a list of pre-defined indexes. Defaults to `BalanceIndex.ACCOUNT_ID`.
    """
    index: BalanceIndexInput
    "Query conditions to filter the balances returned."
    where: BalanceFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): BalanceConnection! @goField(forceResolver: true)

  "All ledger entries associated with accounts in this set and in all subsets."
  entries(
    "Query conditions to filter the entries returned."
    where: AccountSetEntriesFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EntryConnection! @goField(forceResolver: true)

  """
  History of changes to this AccountSet record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountSetConnection! @goField(forceResolver: true)

  "All members of the account set. Sets can include other account sets."
  members(
    "Query conditions to filter the members returned."
    where: AccountSetMembersFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountSetMemberConnection! @goField(forceResolver: true)

  """
  Account sets can be organized into sets. Each account set can belong to zero or multiple account sets.
  """
  sets(
    "Query conditions to filter the account sets returned."
    where: AccountSetFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AccountSetConnection! @goField(forceResolver: true)

  """
  Check the velocity balance for this account set.
  """
  velocity(
    """
    The window of the balance to look up. If
    `velocityLimitId` not provided, will look up
    all velocity limits that support the defined
    window.
    @example({year: "2022", month:"9"})
    """
    window: JSON!
    "The currency for the velocity to look up."
    currency: CurrencyCode! = "USD"
    "If provided, retrieve this specific velocity limit."
    velocityLimitId: UUID
  ): [VelocityBalance] @goField(forceResolver: true)

  "Set of controls attached to this account set."
  controls(first: Int!, after: String! = ""): ResolvedVelocityControlConnection!
    @goField(forceResolver: true)

  """
  Retrieve the calculations that are explicitly attached to this account set.
  """
  calculations: [Calculation!]! @goField(forceResolver: true)
}

"System configuration for an account set."
type AccountSetConfig {
  """
  When `true`, allow concurrent posting to the account.
  See `BalanceType` for balance retrieval options available for concurrent-enabled accounts.
  Defaults to `false`.
  """
  enableConcurrentPosting: Boolean
}

"""
Connection to a list of AccountSet nodes.
Access AccountSet nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type AccountSetConnection implements Connection {
  nodes: [AccountSet]!
  edges: [AccountSetConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of AccountSet nodes.
They contain a reference to the AccountSet node and metadata like the `cursor` position for the edge.
"""
type AccountSetConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the AccountSet node at this edge."
  node: AccountSet
}

"Account set members can be of type Account or AccountSet."
union AccountSetMember = Account | AccountSet

"""
Connection to a list of AccountSetMember nodes.
Access AccountSetMember nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type AccountSetMemberConnection implements Connection {
  nodes: [AccountSetMember!]!
  edges: [AccountSetMemberConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of AccountSetMember nodes.
They contain a reference to the AccountSetMember node and metadata like the `cursor` position for the edge.
"""
type AccountSetMemberConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the AccountSetMember node at this edge."
  node: AccountSetMember
}

"Specify the pre-defined AccountSetIndex and sort order to use in a query."
input AccountSetIndexInput {
  name: AccountSetIndex!
  sort: SortOrder
}

"Indexes for querying AccountSets. To optimize query performance and apply desired filters, choose the appropriate index."
enum AccountSetIndex {
  "Index by `accountSetId` field. Must supply an `accountSetId: { eq: <id> }` filter to the `where` object."
  ACCOUNT_SET_ID
  "Index by `name` field. Use to apply query filters on the value of `name`."
  NAME
  "Index by `code` field. Use to apply query filters on teh value of `code`."
  CODE
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
}

"""
Filter conditions to apply to an account set query.
Filters are only applied if the field is used by the specified index.
"""
input AccountSetFilterInput {
  "Filter on the `accountSetId` field. Required when using index `AccountSetIndex.ACCOUNT_SET_ID`."
  accountSetId: FilterValue
  "Specify the Journal to use with `eq`. Required for all indexes."
  journalId: FilterValue
  "Filter on the `name` field. Only available when using index `AccountSetIndex.NAME`."
  name: FilterValue
  "Fitler on the `code` field. Only available when using index `AccountSetIndex.CODE`."
  code: FilterValue
  "Filter conditions for a custom index. Only available when using index `AccountSetIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `AccountSetIndex.SEARCH`."
  search: SearchFilter
}

"""
Filter conditions to apply when querying members of an account set.
"""
input AccountSetMembersFilterInput {
  "Filter on the `accountSetId` field."
  accountSetId: FilterValue
  "Filter on the `memberId` field: the UUID of a member `Account` or `AccountSet`."
  memberId: FilterValue
}

"Fields to create a new account set."
input AccountSetInput {
  "Unique identifier for the set."
  accountSetId: UUID!
  "The journal for the set. If omitted, the default journal will be used."
  journalId: UUID
  "Name for the set."
  name: String!
  "Description of the account set."
  description: String
  "Determines whether the account set should use a debit- or credit-normal balance."
  normalBalanceType: DebitOrCredit! = CREDIT
  "Metadata attached to this account set."
  metadata: JSON
  "System config for the account set."
  config: AccountSetConfigInput
  "IDs of AccountSets to add this account set to."
  accountSetIds: [UUID]
  "Shorthand code for the account set. If not provided, a default code will be generated."
  code: String
}

"Fields to create a system configuration for an account set."
input AccountSetConfigInput {
  """
  When `true`, allow concurrent posting to the account.
  See `BalanceType` for balance retrieval options available for concurrent-enabled accounts.
  Defaults to `false`.
  """
  enableConcurrentPosting: Boolean

  """
  When `true` use an upsert on the accountSetId index to upsert and avoid unique constraint violation.

  If account set already created, the existing account set is unchanged.
  """
  upsert: Boolean
}

"AccountSet fields to update."
input AccountSetUpdateInput {
  "Name for the set."
  name: String
  "Description of the account set."
  description: String
  "Determines whether the account set should use a debit- or credit-normal balance."
  normalBalanceType: DebitOrCredit
  "Metadata attached to this account set."
  metadata: JSON
  "System config for the account set."
  config: AccountSetConfigInput
  "Shorthand code for the account set."
  code: String
}

"Account set members can be of type Account or AccountSet."
enum AccountSetMemberType {
  ACCOUNT
  ACCOUNT_SET
}

input AccountSetMemberInput {
  "Whether the member to add is an Account or AccountSet"
  memberType: AccountSetMemberType
  """
  Identifier for the member to add.
  When adding accounts, this is the `accountId`.
  When adding account sets, this is the `accountSetId`.
  """
  memberId: UUID!
}

"""
Filter conditions for entries on an AccountSet.
Since accountId and journalId are already known from the parent AccountSet, only currency filtering is needed.
"""
input AccountSetEntriesFilterInput {
  "Filter by currency. Defaults to USD if not specified."
  currency: FilterValue
}

extend type Mutation {
  ach: AchMutation!
}

extend type Query {
  ach: AchQuery!
}

type AchQuery {
  """
  Read an existing configuration for processing ACH files.
  """
  configuration(
    """
    Unique identifier.
    @example("fe27128a-b331-4e0e-94f8-9a32443fee36")
    """
    id: UUID!
  ): AchConfiguration @goField(forceResolver: true)

  configurations(first: Int!, after: String): AchConfigurationConnection!
    @goField(forceResolver: true)

  """
  Read the file info for status of file processing.
  """
  file(
    """
    Unique identifier returned from processFile mutation.
    @example("549f0093-6476-4625-b38e-2109a0d5d3f8")
    """
    id: UUID

    """
    File key of uploaded ACH file.
    @example("ppd-credits.ach")
    """
    fileKey: String

    """
    Configuration identifier used in processFile mutation.
    @example("987908ab-34d4-42f5-9213-c835f96545e1")
    """
    configId: UUID
  ): AchFileInfo @goField(forceResolver: true)

  files(
    index: AchFileInfoIndexInput!
    where: AchFileInfoFilterInput!
    first: Int!
    after: String
  ): AchFileInfoConnection! @goField(forceResolver: true)
}

type AchMutation {
  """
  Create a configuration for processing an ACH file. Defines settlement
  exception and suspense accounts. Defines the endpoint that decisioning
  webhooks are sent to for this configuration.
  """
  createConfiguration(input: AchCreateConfigurationInput!): AchConfiguration
    @goField(forceResolver: true)

  """
  Update an ACH configuration.
  """
  updateConfiguration(configId: UUID!, input: AchUpdateConfigurationInput!): AchConfiguration
    @goField(forceResolver: true)

  """
  "
  Process an ACH file at the file key with the defined configuration.
  """
  processFile(input: AchProcessFileInput!): AchProcessedFile! @goField(forceResolver: true)

  """
  Generate an ACH file.  Currently only generates RDFI return files.
  """
  generateFile(input: AchGenerateFileInput!): AchGeneratedFile! @goField(forceResolver: true)
}

enum AchFileType {
  RDFI
  RDFI_RETURN
  RDFI_NOC
  ODFI
  ODFI_PULL_ONLY
  ODFI_PUSH_ONLY
  ODFI_RETURN
  ODFI_PREPROCESS_RETURN
  ODFI_PROCESSED
}

input AchGenerateFileInput {
  """
  The configuration to use for generating return file.
  """
  configId: UUID!
  """
  The key to store this file.
  """
  fileKey: String!
  """
  The type of file to generate.
  """
  fileType: AchFileType!
  """
  If true, generate empty files. Defaults to true.
  """
  generateEmpty: Boolean! = true
}

type AchGeneratedFile {
  """
  The key where file is stored, if generated.
  """
  fileKey: String!
  """
  Indicates a file was generated or not.
  """
  generated: Boolean!
}

input AchProcessFileInput {
  """
  Configuration to use to process this file.
  """
  configId: UUID!
  """
  The file key to use for this file.
  """
  fileKey: String!
  """
  The type of file being processed.
  """
  fileType: AchFileType!
  """
  Additional ACH processing options.
  """
  options: AchProcessFileOptionsInput
}

input AchProcessFileOptionsInput {
  """
  Output file key for preprocessed files.
  """
  preprocessedFileKey: String

  """
  Optionally output file key for excluded preprocessed entries.
  """
  preprocessedExcludedFileKey: String
}

input AchCreateConfigurationInput {
  """
  Unique identifier for this configuration.
  """
  configId: UUID!
  """
  Endpoint to use for decisioning this ACH file.
  """
  endpointId: UUID!
  """
  Journal to post settlements into.
  """
  journalId: UUID!
  """
  ACH Settlement Account.
  """
  settlementAccountId: UUID!
  """
  Account to post to when an exception occurs, such as a Velocity Control
  or Account in a locked state. Funds in this account will be returned.
  """
  exceptionAccountId: UUID!
  """
  Account to post to when an account is not found. Funds in this account will be
  returned.
  """
  suspenseAccountId: UUID!
  """
  ACH Fee Account.
  """
  feeAccountId: UUID!
  """
  ACH Processor information for files.
  """
  odfiHeaderConfiguration: AchOdfiHeaderConfigurationInput!
  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String!
}

input AchUpdateConfigurationInput {
  """
  Endpoint to use for decisioning this ACH file.
  """
  endpointId: UUID
  """
  Journal to post settlements into.
  """
  journalId: UUID
  """
  ACH Settlement Account.
  """
  settlementAccountId: UUID
  """
  Account to post to when an exception occurs, such as a Velocity Control
  or Account in a locked state. Funds in this account will be returned.
  """
  exceptionAccountId: UUID
  """
  Account to post to when an account is not found. Funds in this account will be returned.
  """
  suspenseAccountId: UUID
  """
  ACH Fee Account.
  """
  feeAccountId: UUID

  """
  ACH Processor information for files.
  **Note:** replaces existing `odfiHeaderConfiguration`
  """
  odfiHeaderConfiguration: AchOdfiHeaderConfigurationInput
  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String
}

input AchOdfiHeaderConfigurationInput {
  immediateDestination: String!
  immediateDestinationName: String!
  immediateOrigin: String!
  immediateOriginName: String!
}
type AchOdfiHeaderConfiguration {
  immediateDestination: String!
  immediateDestinationName: String!
  immediateOrigin: String!
  immediateOriginName: String!
}

type AchConfiguration {
  """
  Unique identifier for this configuration.
  """
  configId: UUID!
  """
  Endpoint to use for decisioning this ACH file.
  """
  endpointId: UUID!
  """
  ACH Settlement Account.
  """
  settlementAccountId: UUID!
  """
  Account to post to when an exception occurs, such as a Velocity Control
  or Account in a locked state. Funds in this account will be returned.
  """
  exceptionAccountId: UUID!
  """
  Account to post to when an account is not found. Funds in this account will be
  returned.
  """
  suspenseAccountId: UUID!
  """
  ACH Fee Account.
  """
  feeAccountId: UUID!
  """
  Journal to post settlements into.
  """
  journalId: UUID!
  """
  ACH Processor immediate destination/origin configuration.
  """
  odfiHeaderConfiguration: AchOdfiHeaderConfiguration!
  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String!

  _recordId: UUID!
  version: Int!
}

type AchConfigurationConnection implements Connection {
  nodes: [AchConfiguration]!
  edges: [AchConfigurationConnectionEdge]!
  pageInfo: PageInfo!
}

type AchConfigurationConnectionEdge {
  cursor: String!
  node: AchConfiguration
}

type AchProcessedFile {
  fileId: UUID!
}

type AchFileInfo implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `afi:<key>` where `key` is `base64(json({ 1: fileId }))`.
  """
  id: ID!
  """
  Unique identifier derived from fileKey to indentify a particular file being processed.
  """
  fileId: UUID!
  """
  The file key being processed.
  """
  fileKey: String!
  """
  TBD
  """
  fileVersion: String!
  """
  File date from header of ACH file.
  """
  fileDate: String!
  """
  File modifier from header of ACH file.
  """
  fileModifier: String!
  """
  The ACH configuration id used to process this file.
  """
  configId: UUID!
  """
  The version number of the configuration used to process this file.
  """
  configVersion: Int!
  """
  The type of file being processed.
  """
  fileType: AchFileType!
  """
  The last reported processing status of this file.
  """
  processingStatus: AchFileProcessingStatus!
  """
  The last string message of the processing detail of this file.
  """
  processingDetail: String!
  """
  Stats about the items in process for this file.
  """
  processingStatistics: AchProcessingStatistics!
  """
  Metadata attached to this file process.
  """
  metadata: JSON
  """
  Timestamp of when this file info was created.
  """
  created: Timestamp!
  """
  Timestamp of the last modification to this file info.
  """
  modified: Timestamp!
  """
  The current version number of this `FileInfo`.
  Previous versions are tracked in `history`.
  """
  version: Int!

  _recordId: UUID!

  """
  History of changes to this ACH file info.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): AchFileInfoConnection! @goField(forceResolver: true)
}

type AchProcessingStatistics {
  """
  The number of entries remaining that need to respond to create webhook.
  """
  numEntriesUnprocessed: Int!

  """
  Total credit amount in the file.
  """
  totalCreditAmount: String!

  """
  Total debit amount in the file.
  """
  totalDebitAmount: String!
}

enum AchFileProcessingStatus {
  """
  File Processing state is unknown.
  """
  UNKNOWN
  """
  Newly created file processing state.
  """
  NEW
  """
  File is being validated.
  """
  VALIDATING
  """
  File is being partitioned for processing.
  """
  PARTITIONING
  """
  File has been uploaded and will begin processing shortly.
  """
  UPLOADED
  """
  File is being processed and create webhooks are being actively sent for this file.
  """
  PROCESSING
  """
  All create webhooks have been sent for this file and entries are awaiting settlement.
  """
  PROCESSED
  """
  The system encountered an unrecoverable error while processing the file. See `processingDetail` for more information.
  """
  ERROR
  """
  The uploaded file failed validation. See `processingDetail` for more information.
  """
  INVALID
  """
  The processing of this file was aborted. See `processingDetail` for more information.
  """
  ABORTED
  """
  All entries from this file process have been either settled or queued for a return file.
  """
  COMPLETED
}

"""
Connection to a list of ACH file nodes.
Access Account nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type AchFileInfoConnection implements Connection {
  nodes: [AchFileInfo]!
  edges: [AchFileInfoConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of ACH file nodes.
They contain a reference to the ACH file node and metadata like the `cursor` position for the edge.
"""
type AchFileInfoConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Account node at this edge."
  node: AchFileInfo
}

"""
Audit trail that links workflow executions to specific ACH entries.
Provides complete traceability from business logic execution to ACH network transactions
enabling returns processing, reconciliation, and compliance auditing.
"""
type AchWorkflowTrace {
  """
  Unique identifier for the workflow template that processed this ACH entry.
  Links to the business logic used for processing this transaction.
  """
  workflowId: UUID!
  """
  Unique identifier for the specific execution instance of the workflow.
  Each workflow run gets a unique execution ID for audit and debugging purposes.
  """
  executionId: UUID!
  """
  Unique identifier for the ACH file containing this entry.
  References the source file that was processed.
  """
  fileId: UUID!
  """
  Unique identifier for the specific ACH entry detail record.
  Links to the individual record within the ACH file.
  """
  recordId: UUID!
  """
  Unique identifier for the ACH configuration used to process this entry.
  References the processing rules, accounts, and ODFI settings applied.
  """
  configId: UUID!
  """
  ACH trace number from the entry detail record (15 digits).
  Required for ACH returns, corrections, and reconciliation with the banking network.
  Format: ODFI routing number (8 digits) + sequence number (7 digits).
  @example("123456780001234")
  """
  traceNumber: String!
}

enum AchFileInfoIndex {
  """
  Index by `processingStatus` field. Must supply both `processingStatus:{eq: <processingStatus>}` and `configId:{eq: <conrfigId>}` to the `where` object.
  """
  PROCESSING_STATUS
}

input AchFileInfoIndexInput {
  name: AchFileInfoIndex!
}

input AchFileInfoFilterInput {
  configId: FilterValue
  processingStatus: FilterValue
  created: FilterValue
}

# TODO: Update graphql api to not require the id input on create mutations. Instead we should be able to auto-generate those.

extend type Mutation {
  "Mutations in the `admin` namespace are used to manage the organization data like users, groups, and tenants."
  admin: AdminMutation!
}

extend type Query {
  "Queries in the `admin` namespace retrieve organization data like users, groups, and tenants."
  admin: AdminQuery!
}

type AdminMutation {
  "Create a new group."
  createGroup("Fields to create a new group." input: CreateGroupInput!): Group
    @goField(forceResolver: true)

  # TODO: doesn't this mutation need the group's ID as an argument?
  "Update an existing group. To ensure data integrity, only a subset of fields are allowed."
  updateGroup("Fields to update." input: UpdateGroupInput!): Group @goField(forceResolver: true)

  "Delete an existing group."
  deleteGroup("Name of group to delete." name: String!): Group @goField(forceResolver: true)

  """
  Create a new human user.

  Upon creation, new users will receive an invite email to sign in to Twisp Console.
  """
  createUser("Fields to create a new user." input: CreateUserInput!): User
    @goField(forceResolver: true)

  # TODO: doesn't this mutation need the user's ID as an argument?
  "Update an existing human user. To ensure data integrity, only a subset of fields are allowed."
  updateUser("Fields to update." input: UpdateUserInput!): User @goField(forceResolver: true)

  "Delete an existing human user."
  deleteUser("Email of user to delete." email: String!): User @goField(forceResolver: true)

  "Create a new tenant."
  createTenant("Fields to create a new tenant." input: CreateTenantInput!): Tenant
    @goField(forceResolver: true)

  # TODO: doesn't this mutation need the tenants's ID as an argument?
  "Update an existing tenant. To ensure data integrity, only a subset of fields are allowed."
  updateTenant("Fields to update." input: UpdateTenantInput!): Tenant @goField(forceResolver: true)

  "Delete an existing tenant."
  deleteTenant("Unique identifier." accountId: String!): Tenant @goField(forceResolver: true)

  "Restore a tenant/region into a new tenant/region"
  restore(input: RestoreInput!): RestoreOutput @goField(forceResolver: true)
}

type AdminQuery {
  "Get the current organization."
  organization: Organization! @goField(forceResolver: true)

  "Get the list of tenants, ordered by `accountId`."
  tenants(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TenantConnection! @goField(forceResolver: true)

  "Get the list of groups, ordered by `name`."
  groups(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): GroupConnection! @goField(forceResolver: true)

  "Get the list of human users, ordered by `email`."
  users(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): UserConnection! @goField(forceResolver: true)

  """
  Retrieves the read and write usage units on per day basis. The metrics returned are on the half open interval.

  @example({"start": "2025-06-01", "end":"2025-07-01"}) returns metris `period >= 2025-06-01T00:00:00.000Z && period < 2025-07-01T00:00:00.000Z`
  """
  usage(input: UsageInput!): Usage @goField(forceResolver: true)
  """
  Retrieves the status of a restoration.
  """
  restoreStatus(executionId: UUID!): RestoreStatus @goField(forceResolver: true)
}

"""
Grouping of users within an organization.

Groups are used to manage access control and permissions for users. Each group can have one or more associated policies that define the allowed actions for its member users.

Users can belong to multiple groups, and their permissions are determined by the combined set of policies from all their groups.
"""
type Group {
  "Unique ID for the group."
  id: UUID!

  "The unique identifier of the organization to which the group belongs."
  organizationId: UUID!

  "A human-friendly name for the group, such as 'Admins' or 'DataAnalysts'."
  name: String!

  "A brief description of the group's purpose, intended to provide additional context."
  description: String!

  """
  A set of policies as a JSON list that define the permissions granted to users within this group.

  The structure of these policies matches the Policy type, but serialized as a JSON string.

  Example:

  ```
  policy: "[{\"actions\": [\"*\"],\"effect\": \"DENY\",\"resources\":[\"*\"],\"assertions\": {\"always false\": \"1 == 0\"}}]"
  ```
  """
  policy: String!

  "The current version number of this group. Updates will increment the version."
  version: Int!

  _recordId: UUID!
}

input CreateGroupInput {
  "Unique ID for the group."
  id: UUID!

  "A human-friendly name for the group, such as 'Admins' or 'DataAnalysts'."
  name: String!

  "A brief description of the group's purpose, intended to provide additional context."
  description: String!

  """
  A set of policies to apply to this group, formatted as a JSON list that define the permissions granted to users within this group.

  The structure of these policies matches the Policy type, but serialized as a JSON string.

  Example:

  ```
  policy: "[{\"actions\": [\"*\"],\"effect\": \"DENY\",\"resources\":[\"*\"],\"assertions\": {\"always false\": \"1 == 0\"}}]"
  ```
  """
  policy: String!
}

input UpdateGroupInput {
  "A human-friendly name for the group, such as 'Admins' or 'DataAnalysts'."
  name: String!

  "A brief description of the group's purpose, intended to provide additional context."
  description: String

  """
  A set of policies to apply to this group, formatted as a JSON list that define the permissions granted to users within this group.

  Valid actions include `db:Insert`, `db:Update`, `db:Delete`, `db:Select` or wildcard `*`

  Example:

  ```
  policy: "[{\"actions\": [\"*\"],\"effect\": \"DENY\",\"resources\":[\"*\"],\"assertions\": {\"always false\": \"1 == 0\"}}]"
  ```
  """
  policy: String
}

"""
Connection to a list of Group nodes.
Access Group nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type GroupConnection implements Connection {
  nodes: [Group]!
  edges: [GroupConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Group nodes.
They contain a reference to the Group node and metadata like the `cursor` position for the edge.
"""
type GroupConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Group node at this edge."
  node: Group
}

"""
The organization associated with the auth context.

Organizations have many tenants, groups, and users.
"""
type Organization {
  "Unique ID for the organization."
  id: UUID!

  "Name of the organization."
  name: String!

  "Description of the organization."
  description: String!

  "The current version number of this organization."
  version: Int!

  _recordId: UUID!
}

"""
A human user within the organization.

Users can belong to multiple groups, which define their permissions within the organization based on the associated policies of each group.

The user's effective permissions are determined by the combined set of policies from all their groups.

A user is uniquely identified by their email address.
"""
type User {
  "Unique ID for the user."
  id: UUID!

  "ID of the user's parent organization."
  organizationId: UUID!

  "A list of unique identifiers for the groups to which the user belongs. The user's permissions are determined by the combined policies of these groups."
  groupIds: [UUID!]!

  "The user's email address, which serves as a unique identifier and primary means of contact."
  email: String!

  "The current version number of this user. Updates will increment the version."
  version: Int!

  """
  Returns if the users MFA is enabled.
  """
  mfaEnabled: Boolean! @goField(forceResolver: true)

  # subject: UUID! "subject is currently a reserved field and should not be exposed to users"

  _recordId: UUID!
}

input CreateUserInput {
  "Unique ID for the user."
  id: UUID!

  "A list of unique identifiers for the groups to which the user belongs. The user's permissions are determined by the combined policies of these groups."
  groupIds: [UUID!]!

  "The user's email address, which serves as a unique identifier and primary means of contact."
  email: String!

  # subject: UUID! "subject is currently a reserved field and should not be exposed to users"
}

input UpdateUserInput {
  "A list of unique identifiers for the groups to which the user belongs. The user's permissions are determined by the combined policies of these groups."
  groupIds: [UUID!]

  "The user's email address, which serves as a unique identifier and primary means of contact."
  email: String!
}

"""
Connection to a list of User nodes.
Access User nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type UserConnection implements Connection {
  nodes: [User]!
  edges: [UserConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of User nodes.
They contain a reference to the User node and metadata like the `cursor` position for the edge.
"""
type UserConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the User node at this edge."
  node: User
}

"""
A Tenant represents an environment within an organization, typically associated with a specific application, service, or set of resources. Tenants contain isolated ledgers, each deployed to a specific region.

Tenants are useful for isolating data and configurations between different environments. Each tenant is uniquely identified by an accountId, which in combination with an AWS region, is used to calculate the database tenant for data isolation purposes.
"""
type Tenant {
  "Unique ID for the tenant."
  id: UUID!

  "ID of the tenant's parent organization."
  organizationId: UUID!

  """
  A globally unique identifier representing an environment within the organization.

  This accountId, when combined with an AWS region, is used to calculate the database tenant.
  """
  accountId: String!

  "A human-friendly name for the tenant, used for display purposes and easier identification."
  name: String!

  "A brief description of the tenant, providing additional context about its purpose or characteristics."
  description: String!

  "The current version number of this tenant. Updates will increment the version."
  version: Int!

  _recordId: UUID!
}

input CreateTenantInput {
  "Unique ID for the tenant."
  id: UUID!

  """
  A globally unique identifier representing an environment within the organization.

  This accountId, when combined with an AWS region, is used to calculate the database tenant.
  """
  accountId: String!

  "A human-friendly name for the tenant, used for display purposes and easier identification."
  name: String!

  "A brief description of the tenant, providing additional context about its purpose or characteristics."
  description: String!
}

input UpdateTenantInput {
  """
  A globally unique identifier representing an environment within the organization.

  This accountId, when combined with an AWS region, is used to calculate the database tenant.
  """
  accountId: String!

  "A human-friendly name for the tenant, used for display purposes and easier identification."
  name: String

  "A brief description of the tenant, providing additional context about its purpose or characteristics."
  description: String
}

"""
Connection to a list of Tenant nodes.
Access Tenant nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type TenantConnection implements Connection {
  nodes: [Tenant]!
  edges: [TenantConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Tenant nodes.
They contain a reference to the Tenant node and metadata like the `cursor` position for the edge.
"""
type TenantConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Tenant node at this edge."
  node: Tenant
}

enum ExcludeTableEnum {
  Account
  AccountContext
  AccountSet
  AccountSetMember
  AttachedCalculation
  Balance
  BulkExecution
  Calculation
  Endpoint
  Entry
  Journal
  Transaction
  TransactionException
  TranCode
  VelocityControl
  VelocityControlAccount
  VelocityLimit
  WorkflowExecution
}

input RestoreInput {
  """
  The region in the current tenant to restore from.
  """
  from_region: String!
  """
  The region in the target `tenant` to restore to.
  """
  to_region: String!
  """
  The target tenant to create for restoration.
  """
  tenant: CreateTenantInput!
  """
  List of tables to exclude from restoration.
  """
  excludeTables: [ExcludeTableEnum!]
  """
  Timestamp, up to 35 days in the past, to indicate from what time to export.
  """
  exportTime: Timestamp
  """
  List of glob patterns for files to include in restoration.
  By default no files are restored. Must supply patterns to restore files.
  Example: ["*.json"] includes all top level json files.
  """
  includeFileGlobs: [String!]
}

type RestoreOutput {
  execution_id: UUID!
}

input UsageInput {
  """
  Start date at midnight UTC.
  """
  start: Date!
  """
  End date at midnight UTC.
  """
  end: Date!
}

type Usage {
  """
  The number of read units in the period listed.
  """
  readUnits: [UsageDatum]
  """
  The number of write units in the period listed.
  """
  writeUnits: [UsageDatum]
  """
  The number of RPU seconds charged.
  Twisp bills per hour so divide `warehouseRPUSeconds.units / 3600` for billing purposes.
  """
  warehouseRPUSeconds: [UsageDatum]
}

type UsageDatum {
  period: Date
  units: Int
}

enum RestoreStatusEnum {
  EXPORTING
  IMPORTING
  COMPLETE
  ERROR
}

type RestoreStatus {
  executionId: UUID!
  status: RestoreStatusEnum!
  error: String
}

extend type Mutation {
  "Mutations in the `auth` namespace are used to manage clients and their policies. Use the `createClient` mutation to create a new client, `updateClient` to update an existing client, and `deleteClient` to delete a client."
  auth: AuthMutation!
}

extend type Query {
  "Queries in the `auth` namespace are used to retrieve clients and their policies. Use the `client` query to retrieve a single client, and `clients` to retrieve a list of clients."
  auth: AuthQuery!
}

type AuthMutation {
  "Create a new security client."
  createClient(input: CreateClientInput!): Client! @goField(forceResolver: true)

  "Update an existing client by replacing policies."
  updateClient(
    "Principal of the client to update."
    principal: String!
    "Client fields to update."
    input: UpdateClientInput!
  ): Client @goField(forceResolver: true)

  "Delete a security client."
  deleteClient("Principal to delete.", principal: String!): Client @goField(forceResolver: true)
}

type AuthQuery {
  "Get a single client by the `principal`."
  client(
    "Principal of the client."
    principal: String!
  ): Client @goField(forceResolver: true)

  "Lists all clients."
  clients(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): ClientConnection! @goField(forceResolver: true)
}

"""
Connection to a list of Client nodes.
Access Client nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type ClientConnection implements Connection {
  nodes: [Client]!
  edges: [ClientConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Client nodes.
They contain a reference to the Client node and metadata like the `cursor` position for the edge.
"""
type ClientConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Client node at this edge."
  node: Client
}

input CreateClientInput {
  """
  Principal that this client applies to.
  If you're supplying your own OIDC this will be the `iss` claim on your JWT.
  If using Twisp IAM/OIDC token exchange, this will be the IAM principal you signed with, typically a role ARN.
  """
  principal: String!

  "Unique name of the client."
  name: String!

  "The policies to evaluate."
  policies: [PolicyInput]!
}

input UpdateClientInput {
  "Replaces the existing policies with this new set of policies."
  policies: [PolicyInput]!
}

type Client implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `cl:<key>` where `key` is the `base64(json({ 1: principal }))`
  """
  id: ID!

  """
  Principal that this client applies to.
  If you're supplying your own OIDC this will be the `iss` claim on your JWT.
  If using Twisp IAM/OIDC token exchange, this will be the IAM principal you signed with, typically a role ARN.
  """
  principal: String!

  "Unique name of the client."
  name: String!

  "The policies to evaluate."
  policies: [Policy]!
}

input PolicyInput {
  "Whether this Policy is an `ALLOW` or `DENY`."
  effect: PolicyEffect!

  """
  The set of actions to allow or deny.
  """
  actions: [PolicyAction]!

  """
  The resources to allow or deny.
  In the format `<namespace>.<resource>`

  The following namespaces exist:
  - `financial`
  - `tenancy`
  - `public`
  - `system`

  As do the following resources in the financial namespace:

  - `Account`
  - `AccountSet`
  - `AccountSetMember`
  - `Transaction`
  - `Entry`
  - `Balance`
  - `TranCode`
  - `Journal`

  You can use `*` to wildcard as well.
  """
  resources: [String]!

  """
  A map of expressions to evaluate this policy with.
  """
  assertions: ExpressionMap
}

type Policy {
  "Whether this Policy is an `ALLOW` or `DENY`."
  effect: PolicyEffect!

  """
  The set of actions to allow or deny."
  """
  actions: [PolicyAction]!

  """
  The resources to allow or deny.
  """
  resources: [String]!

  """
  A map of expressions to evaluate this policy with.
  """
  assertions: ExpressionMap
}

type PolicyAssertion {
  name: String!
  value: Expression!
}

enum PolicyAction {
  SELECT,
  INSERT,
  UPDATE,
  DELETE
}

enum PolicyEffect {
  ALLOW
  DENY
}

extend type Query {
  "Get a balance for an account."
  balance(
    "ID of the journal for the balance. If omitted, the default journal will be used."
    journalId: UUID

    "ID of the account for the balance."
    accountId: UUID!

    "Currency of the balance."
    currency: CurrencyCode! = "USD"

    "If provided, look up based on calculation id and dimensions for calculation."
    calculationId: UUID

    "If provided, look up based on calculation id and dimensions for calculation. The values in this should be string representation of values."
    dimension: JSON

    "If enabled and provided, look up balances based on effective date."
    effective: Effective

    "If concurrent enabled, compute balance with all visible transactions."
    materialize: Boolean

    "If concurrent enabled, the isolation level of the balance returned."
    type: BalanceType
  ): Balance

  "Select one or more balances. Specify the index to use and apply filters to your query."
  balances(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: BalanceIndexInput!

    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: BalanceFilterInput

    "Number of nodes to return on the connection."
    first: Int!

    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): BalanceConnection!
}

input Effective {
  """
  Cumulative account balance as of a particular effective date.
  @example("2023-10-17")
  """
  cumulative: Date

  """
  Account balance of a particular effective time period. Supported periods are in formats: `YYYY`, `YYYY-MM`, `YYYY-MM-DD`.
  Useful for reconciliation/balances files.
  @example("2023-10")
  """
  period: String

  """
  Effective account balances over a range of time periods. Useful for income statement.
  @example({gte: "2023-10", lte: "2023-12"})
  """
  range: PeriodRange

  "Optional point-in-time filter for resolving historical effective balances."
  where: BalanceHistoryFilterInput
}

input PeriodRange {
  lte: String
  gte: String
}

type BalanceAmount {
  "Sum of all amounts for entries on the DEBIT side of the ledger."
  drBalance: Money!

  "Sum of all amounts for entries on the CREDIT side of the ledger."
  crBalance: Money!

  """
  The "normal balance" for an account is different for credit normal and debit normal accounts.

  For credit normal accounts, the normal balance is equal to `crBalance - drBalance`.
  For debit normal accounts, the normal balance is the reverse: `drBalance - crBalance`.
  """
  normalBalance: Money!

  "ID of the most recent entry used to calculate the balance on this layer."
  entryId: UUID!

  "Time of the last change of balance on this layer."
  modified: Timestamp!
}

"""
Balances are auto-calculated sums of the entries for a given account.

Every balance record maintains a `drBalance` for entries on the debit side of the ledger and a `crBalance` for credit entries.

Additionally, every account has a `normalBalance`, which is equal to `crBalance - drBalance` for credit normal accounts, and `drBalance - crBalance` for debit normal accounts.

Each account can have balances across all three layers: SETTLED, PENDING, and ENCUMBRANCE.
"""
type Balance implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `ba:<key>` where `key` is `base64(json({ 1: accountId, 2: journalId, 3: currency, 4: calculationId, 5: dimension }))`
  The journalId and currency are optional and will use the default values if they are missing.
  The calculationId and dimension are included for calculation-specific balances.
  """
  id: ID!

  "ID of the journal within which the balance is calculated."
  journalId: UUID!

  "ID of the account for which the balance is calculated."
  accountId: UUID!

  "ID of the most recent entry used to calculate the balance."
  entryId: UUID!

  """
  The currency of the balance amounts.

  Balances represent the sum of entries using the same currency. Multi-currency ledgers will therefore have different balances for each currency.
  """
  currency: CurrencyCode!

  "The balance amounts on the settled layer."
  settled: BalanceAmount!

  "The balance amounts on the pending layer."
  pending: BalanceAmount!

  "The balance amounts on the encumbrance layer."
  encumbrance: BalanceAmount!

  "The dimensions that make up this balance calculation"
  dimensions: JSON

  "The calculationId of this balance"
  calculationId: UUID!

  "The balance amounts available by combining the provided layer with all layers above."
  available(layer: Layer!): BalanceAmount! @goField(forceResolver: true)

  "Date and time when the balance was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this balance. Previous versions are tracked in `history`."
  version: Int!

  _direction: DebitOrCredit!
  _recordId: UUID!

  _effectiveBalances: [Balance!]

  "Reference to the balance's account."
  account: Account! @goField(forceResolver: true)

  "Reference to the most recent entry used to calculate the balance."
  entry: Entry! @goField(forceResolver: true)

  "All ledger entries for this balance."
  entries(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EntryConnection! @goField(forceResolver: true)

  "Reference to the balance's journal."
  journal: Journal! @goField(forceResolver: true)

  """
  History of changes to this Balance record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
    "Filter the history query according to specified conditions."
    where: BalanceHistoryFilterInput
  ): BalanceConnection! @goField(forceResolver: true)
}

"""
Connection to a list of Balance nodes.
Access Balance nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type BalanceConnection implements Connection {
  nodes: [Balance]!
  edges: [BalanceConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Balance nodes.
They contain a reference to the Balance node and metadata like the `cursor` position for the edge.
"""
type BalanceConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Balance node at this edge."
  node: Balance
}

"Specify the pre-defined BalanceIndex and sort order to use in a query."
input BalanceIndexInput {
  name: BalanceIndex!
  sort: SortOrder
}

"Indexes for querying Balances. To optimize query performance and apply desired filters, choose the appropriate index."
enum BalanceIndex {
  "Index by `accountId` field. Must supply an `accountId: { eq: <id> }` filter to the `where` object."
  ACCOUNT_ID
  "Index by `calculationId` and `dimension` fields in addition to account."
  CALCULATION
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
}

"""
Filter conditions to apply to a balance query.
Filters are only applied if the field is used by the specified index.
"""
input BalanceFilterInput {
  "Specify the Journal to use with `eq`. If omitted, the default journal will be used."
  journalId: FilterValue
  "Filter on the `accountId` field. Required when using index `BalanceIndex.ACCOUNT_ID`."
  accountId: FilterValue
  "Filter on the `currency` field."
  currency: FilterValue
  "Filter on `calculationId` field when using `BalanceIndex.DIMENSION`"
  calculationId: FilterValue
  "Filter on `dimension` field when using `BalanceIndex.Dimension`"
  dimension: DimensionFilterValue
  "Filter conditions for a custom index. Only available when using index `BalanceIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `BalanceIndex.SEARCH`."
  search: SearchFilter
}

"""
Filter conditions to apply to a balance history query.
"""
input BalanceHistoryFilterInput {
  "Filter on the `modified` timestamp."
  modified: FilterValue
  "Filter on the transaction commit timestamp for the specific balance record version."
  committed: FilterValue
}

extend type Query {
  bulk: BulkQuery!
}

extend type Mutation {
  bulk: BulkMutation!
}

type BulkQuery {
  "Retrieve single bulk query execution by it's `executionId`."
  execution(id: UUID!): BulkQueryExecution @goField(forceResolver: true)
}

type BulkMutation {
  execute(input: BulkQueryInput): BulkQueryExecution @goField(forceResolver: true)
}

type BulkQueryExecution {
  "Human readable name of this bulk execution."
  name: String!
  "Key to variables file to use."
  key: String!
  "Unique Identifier for this execution of a bulk query."
  executionId: UUID!
  "Parameterized GraphQL query string to execute."
  query: String!
  "Status of this execution."
  status: BulkQueryExecutionStatus!
  "Set when `status` is `COMPLETE`, lists the keys to download the results files."
  resultKeys: [String!] @goField(forceResolver: true)
  "If `status` in error, a diagnostic message for the cause of the error."
  error: String
  "Summary of the bulk query execution. Populated on COMPLETE or ERROR."
  summary: BulkQueryExecutionSummary

  created: Timestamp!
  modified: Timestamp!
}

type ResultKeyConnection implements Connection {
  nodes: [String]!
  edges: [ResultKeyConnectionEdge]!
  pageInfo: PageInfo!
}

type ResultKeyConnectionEdge {
  cursor: String!
  node: String!
}

type BulkQueryExecutionSummary {
  "total number of requests in this execution."
  total: Int!
  "Summary of executed requests."
  executed: ExecutedSummary!
  """
  Summary of aborted requests due to aborted execution.
  The requests in FAILED_N.json _may not_ have been executed.
  The requests in PENDING_N.json _were not_ executed.
  """
  aborted: AbortedSummary!
}

type ExecutedSummary {
  "Number of executed requests."
  count: Int!
  """
  Of the requests executed, counts of results by status error code.
  Successful are "OK". If only keys are "OK" and "UNIQUE_KEY_VIOLATION"
  all the requests in the bulk execution succeeded or already exists.
  """
  status: JSON
}

type AbortedSummary {
  "Number of aborted requests."
  count: Int!
  "Errors from the FAILED_N.json files."
  errors: [FailedBulkExecutionError]
}

type FailedBulkExecutionError {
  error: String!
  cause: String!
}

enum BulkQueryExecutionStatus {
  "Execution is created but not yet started."
  CREATED
  "Execution is in progress."
  IN_PROGRESS
  "Execution is complete and results are being summarized."
  SUMMARIZING
  "Execution is complete and results are available to download."
  COMPLETE
  "There was an error that prevented execution."
  ERROR
}

input BulkQueryInput {
  "Human readable name of this bulk execution."
  name: String = "Bulk Query"
  "Key to file to execute."
  key: String!
  "Unique Identifier for this execution of a bulk query."
  executionId: UUID!
  "Parameterized GraphQL query string to execute."
  query: String!
  """
  Optional jq transform to run on variables in file identified by `key`.
  The result of the transform must be a list of json variables.

  @example("map(.accountId)")
  """
  transform: String
}

extend type Query {
  "Retrieve a calculation by its identifier."
  calculation(calculationId: UUID!): Calculation

  "Retrieve calculations by index."
  calculations(
    index: CalculationIndexInput!
    where: CalculationFilterInput
    first: Int!
    after: String
  ): CalculationConnection!
}

extend type Mutation {
  "Create a calculation, which allows for balances to be customized on dimensions/filters."
  createCalculation(input: CreateCalculationInput!): Calculation!

  """
  "
  Delete calculation sets calculation to `LOCKED`. If in attached scope, must remove all attachments first.
  """
  deleteCalculation("Unique identifier." id: UUID!): Calculation

  """
  Attaches a calculation to an account or account set for entries on the specified journal.
  """
  attachCalculation(input: AttachCalculationInput!): AttachedCalculation!

  """
  Removes calculation from attachment.
  """
  detachCalculation(input: DetachCalculationInput!): AttachedCalculation
}

input CalculationIndexInput {
  name: CalculationIndex!
  sort: SortOrder
}

enum CalculationIndex {
  "Index by `calculationId` field. Must supply `calculationId: { eq: <id> }` filter to the `where` object."
  CALCULATION_ID
  "Index by `code` field. Must supply `code: { eq: <id> }` filter to the `where` object."
  CODE
  "Global calculations by `status` field. Must supply `status: { eq: <id> }` filter to the `where` object."
  GLOBAL
  "Local calculations by `status` field. Must supply `status: { eq: <id> }` filter to the `where` object."
  LOCAL
}

input CalculationFilterInput {
  calculationId: FilterValue
  code: FilterValue
  status: FilterValue
}

"""
Connection to a list of Calculation nodes.
Access Calculation nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type CalculationConnection implements Connection {
  nodes: [Calculation]!
  edges: [CalculationConnectionEdge]!
  pageInfo: PageInfo!
}

type CalculationConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Calculation node at this edge."
  node: Calculation
}

input CreateCalculationInput {
  "Unique identifier for this calculation."
  calculationId: UUID!

  "Unique shorthand code for this balance calculation."
  code: String!

  "Human readable description of this calculation."
  description: String!

  """
  The calculation scope of this calculation. Defaults to `GLOBAL`.
  """
  scope: CalculationScope! = GLOBAL

  """
  Group by these values to index the calculation.

  The `account`, `transaction` and `entry` are available for use in the dimension computation on `context.vars`.
  """
  dimensions: [PartitionKeyInput]!

  """
  A boolean expression indicating if an balance entry should be written.
  The `account`, `transaction`, `tranCode` and `entry` are available for use in the dimension computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression

  """
  Configuration options for this calculation.
  """
  config: CalculationConfigInput
}

input CalculationConfigInput {
  """
  Enable effective date calculations. Creates 3 child calculations for YYYY, YYYY_MM, and YYYY_MM_DD.
  Effective date dimensions are prepended to custom dimensions.
  """
  enableEffectiveBalances: Boolean! = false
}

enum CalculationBackfillStatus {
  "Calculation is completely backfilled or was created before backfill support."
  COMPLETE
  "Backfill is in progress."
  IN_PROGRESS
  "There was an error in the backfill."
  ERROR
  "The calculation was detached."
  DETACHED
}

enum CalculationScope {
  """
  The calculation is computed on all accounts and sets in the journal.
  """
  GLOBAL
  """
  The calculation is computed only on accounts and sets where it is attached.
  """
  LOCAL
}

enum EffectiveGranularity {
  "Year-level effective calculation (YYYY)"
  YEAR
  "Month-level effective calculation (YYYY_MM)"
  MONTH
  "Day-level effective calculation (YYYY_MM_DD)"
  DAY
}

type Calculation implements Node {
  id: ID!

  "Unique identifier for this calculation."
  calculationId: UUID!

  "Unique shorthand code for this calculation."
  code: String!

  "Human readable description of this calculation."
  description: String!

  """
  The calculation scope of this calculation.
  """
  scope: CalculationScope!

  "Group by these values to index the calculation."
  dimensions: [PartitionKey]!

  "Boolean expression indicating if a balance entry should be written."
  condition: Expression

  "Date and time when the balance calculation was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this calculation. Previous versions are tracked in `history`."
  version: Int!

  "The current backfill status."
  backfillStatus: CalculationBackfillStatus!

  "The status of this calculation."
  status: CalculationStatus!

  "Config options for this calculation."
  config: CalculationConfig

  _recordId: UUID!
}

type CalculationConfig {
  "Whether this calculation has effective date child calculations."
  enableEffectiveBalances: Boolean!
}

enum CalculationStatus {
  """
  Calculation is actively in use.
  """
  ACTIVE
  """
  Calculation has been deleted and no longer in use.
  """
  LOCKED
}

input AttachCalculationInput {
  """
  Journal to attach calculation to. This parameter is ignored when attaching to an account set.
  Defaults to the default journal if not provided when attaching to an account.
  """
  journalId: UUID
  """
  Account or Account Set to attach calculation to.
  """
  accountId: UUID!
  """
  Calculation to attach.
  """
  calculationId: UUID!
}

input DetachCalculationInput {
  """
  Journal to detach calculation.
  """
  journalId: UUID
  """
  Account or set to detach calculation.
  """
  accountId: UUID!
  """
  Calculation to detach.
  """
  calculationId: UUID!
}

type AttachedCalculation {
  journalId: UUID!
  accountId: UUID!
  calculationId: UUID!

  account: Account! @goField(forceResolver: true)
  calculation: Calculation! @goField(forceResolver: true)
}

extend type Mutation {
  "Mutations in the `cards` namespace are used to initialize card processing transaction codes, including specific implementations like the Lithic card processing webhook."
  cards: CardMutation!
}

type CardMutation {
  """
  DEPRECATED: Use Lithic workflow in workflow namespace.

  Initialize your Twisp instance with Card Processing Transaction Codes. Returns the default settlement account.
  """
  initializeCardTransactionCodes(input: CardInitializeInput!): Account! @goField(forceResolver: true)

  """
  DEPRECATED: Use Lithic workflow in workflow namespace.

  This mutation supports converting Lithic [Transaction Webhooks JSON](https://docs.lithic.com/docs/transaction-webhooks#schema) into into Twisp accounting core using our card transaction codes.

  This mutation supports all lithic transaction webhook payloads, including ASA and Balance Inquiry. The general approach is to post all webhooks to Twisp, utilize the balances that come back for decisioning, and allow Twisp and Lithic to work together to track the state of the authorization/settlement cycle.
  """
  postLithicTransaction(input: LithicTransactionInput!): LithicTransactionBalance! @goField(forceResolver: true)
}


input CardInitializeInput {
  """
  The unique identifier for the journal that card transactions will post to by default.
  If omitted, the default journal will be used.
  """
  journalId: UUID

  """
  A unique identifier to an existing settlement account that
  card transactions will post to by default. If not provided,
  a default card transaction account will be used as the
  settlement account.
  """
  settlementAccountId: UUID
}

input LithicTransactionInput {
  "Unique identifier for the account this transaction will post to."
  accountId: UUID!

  """
  The [Transaction](https://docs.lithic.com/docs/transactions)
  webhook object from Lithic.
  """
  webhook: JSON!

  """
  Unique identifier for the journal this transaction applies to.
  If not provided, defaults to the default journal that card transaction codes are configured with.
  """
  journalId: UUID

  """
  Unique identifier of the settlement account that transactions
  will settle from. If not provided, defaults to the default
  card settlement account.
  """
  settlementAccountId: UUID
}

type LithicTransactionBalance {
  """
  The transaction that Twisp posted.
  """
  transaction: Transaction!

  """
  The balance for the account.
  """
  balance: Balance!
}


extend type Query {
  "Get a single entry by its `entryId`."
  entry("Unique identifier." id: UUID!): Entry

  "Select one or more entries. Specify the index to use and apply filters to your query."
  entries(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: EntryIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: EntryFilterInput
    """
    Return the first n-edges of a search. Use `after` to paginate forward.
    """
    first: Int
    """
    Return previous n-edges of a search relative to the `before` cursor.
    **NOTE:** only available on search indexes.
    """
    last: Int
    """
    Cursor to paginate forward through a search result.
    When no cursor is provided, the query uses the default starting cursor.
    """
    after: String
    """
    Cursor to paginate backwards through a search result.

    **NOTE:** Only available on search indexes.
    """
    before: String
  ): EntryConnection!
}

extend type Mutation {
  "Update an existing ledger entry. To ensure data integrity, only a subset of fields are allowed."
  updateEntry("Unique identifier." id: UUID!, input: EntryUpdateInput!): Entry!
}

"""
An entry represents one side of a transaction in a ledger. In other systems, these may be called "ledger lines" or "journal entries".

Entries always have an account, amount, and direction (CREDIT or DEBIT). In addition, Twisp uses the concept of "entry types" to assign every entry to a categorical type.

Twisp enforces double-entry accounting, which in practice means that entries can only be entered in the context of a Transaction. Posting a transaction will create _at least 2_ ledger entries.
"""
type Entry implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `en:<key>` where `key` is `base64(json({ 1: entryId }))`.
  """
  id: ID!

  "Unique identifier for the ledger entry."
  entryId: UUID!

  "Unique identifier for the transaction which posted this entry. Every entry is associated with a transaction."
  transactionId: UUID!

  "ID of the account to be debited/credited."
  accountId: UUID!

  "The journal identifier of the ledger entry."
  journalId: UUID!

  "Type code for the entry."
  entryType: EntryType!

  "The layer on which this entry is recorded (SETTLED, PENDING, or ENCUMBRANCE)."
  layer: Layer!

  "Syntactic sugar for `amount { units }`."
  units: Decimal!

  "Syntactic sugar for `amount { currency }`."
  currency: CurrencyCode!

  "Amount of the ledger entry using the currency-supported Money type."
  amount: Money!

  "The side of the ledger (DEBIT or CREDIT) this entry is posted on."
  direction: DebitOrCredit!

  """
  The order in which this entry was posted within the context of a transaction.

  This order is auto-generated at time of posting and is determined by the position of the entries posted within the transaction.
  """
  sequence: Int!

  "Description of the ledger entry."
  description: String!

  "Arbitrary structured data about this entry."
  metadata: JSON

  "Account sets this entry was posted to."
  parentAccountIds: [UUID!]

  "Date and time when the entry was posted."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this entry. Previous versions are tracked in `history`."
  version: Int!

  _recordId: UUID!
  _balanceRecordId: UUID!
  _balanceRecordVersion: Int!

  "Reference to the account to be debited/credited."
  account: Account! @goField(forceResolver: true)

  "Reference to the resulting balance from the entry."
  balance: Balance @goField(forceResolver: true)

  "Reference to the journal of the entry."
  journal: Journal! @goField(forceResolver: true)

  """
  History of changes to this Entry record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EntryConnection! @goField(forceResolver: true)

  "Reference to the transaction which posted this entry."
  transaction: Transaction! @goField(forceResolver: true)
}

"""
Connection to a list of Entry nodes.
Access Entry nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type EntryConnection implements Connection {
  nodes: [Entry]!
  edges: [EntryConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Entry nodes.
They contain a reference to the Entry node and metadata like the `cursor` position for the edge.
"""
type EntryConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Entry node at this edge."
  node: Entry
}

"Specify the pre-defined EntryIndex and sort order to use in a query."
input EntryIndexInput {
  name: EntryIndex!
  sort: SortOrder
}

"Indexes for querying Entries. To optimize query performance and apply desired filters, choose the appropriate index."
enum EntryIndex {
  "Index by `entryId` field. Must supply an `entryId: { eq: <id> }` filter to the `where` object."
  ENTRY_ID
  "Index by `transactionId` field. Must supply an `transactionId: { eq: <id> }` filter to the `where` object."
  TRANSACTION_ID
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
}

"""
Filter conditions to apply to an entry query.
Filters are only applied if the field is used by the specified index.
"""
input EntryFilterInput {
  "Filter on the `entryId` field. Required when using index `EntryIndex.ENTRY_ID`."
  entryId: FilterValue
  # TODO: Not currently applied in any index
  # "Specify the Journal to use with `eq`. Required for all indexes."
  journalId: FilterValue
  # TODO: Not currently applied in any index
  # "Filter on the `currency` field. Only available when using index `N/A`."
  currency: FilterValue
  # TODO: Not currently applied in any index
  # "Filter on the `layer` field. Only available when using index `N/A`."
  layer: FilterValue
  "Filter on the `transactionId` field. Required when using index `EntryIndex.TRANSACTION_ID`."
  transactionId: FilterValue
  "Filter conditions for a custom index. Only available when using index `EntryIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `EntryIndex.SEARCH`."
  search: SearchFilter
}

"Entry fields to update."
input EntryUpdateInput {
  "Description of the entry."
  description: String
  "Metadata attached to this entry."
  metadata: JSON
}

extend type Query {
  "Mutations in the `events` namespace are used to manage event subscriptions, such as webhooks."
  events: EventsQuery!
}

extend type Mutation {
  "Queries in the `events` namespace retrieve event data, such as webhooks."
  events: EventsMutation!
}

type EventsQuery {
  "Get a single endpoint by it's `endpointId`"
  endpoint(
    id: UUID!
  ): Endpoint @goField(forceResolver: true)

  "Select one or more endpoints. Specify the index to use and apply filters to your query."
  endpoints(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: EndpointIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: EndpointFilterInput!
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EndpointConnection! @goField(forceResolver: true)
}

type EventsMutation {
  "Create a new endpoint."
  createEndpoint("Fields to create a new endpoint." input: EndpointInput!): Endpoint! @goField(forceResolver: true)

  "Update fields on an existing account. To ensure data integrity, only a subset of fields are allowed."
  updateEndpoint(
    "Unique identifier."
    id: UUID!
    "Fields to update."
    input: EndpointUpdateInput!
  ): Endpoint @goField(forceResolver: true)

  deleteEndpoint("Unique identifier." id: UUID!): Endpoint @goField(forceResolver: true)
}

type Endpoint implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `ep:<key>` where `key` is `base64(json({ 1: endpointId }))`.
  """
  id: ID!
  "Unique identifier for the endpoint."
  endpointId: UUID!
  "Current status for the endpoint."
  status: EndpointStatus!
  "The type of endpoint this represents."
  endpointType: EndpointType!
  "The url for the endpoint. e.g.  https://yourdomain.com/path/to/hooks"
  url: String!
  "The events this is subscribed to."
  subscription: [String!]!
  "Description of this endpoint."
  description: String!
  "The secret Twisp will use to sign payloads with via HMAC/SHA256."
  signingSecret: String!
  """
  Map of named CEL expressions specifying conditions for sending an event to the endpoint.

  Record is only sent if _all_ expressions evaluate to true, i.e. they are combined with a logical AND. Each expression must return a boolean value.
  """
  filters: ExpressionMap
  "When this endpoint was created."
  created: Timestamp!
  "When this endpoint was last updated."
  modified: Timestamp!
  "The current version of the endpoint."
  version: Int!

  _recordId: UUID!
}

type EndpointConnection implements Connection {
  nodes: [Endpoint]!
  edges: [EndpointConnectionEdge]!
  pageInfo: PageInfo!
}

type EndpointConnectionEdge {
  cursor: String!

  node: Endpoint
}

input EndpointIndexInput {
  name: EndpointIndex!
  sort: SortOrder
}

enum EndpointIndex {
  "Index by `endpointId` field. Must supply an `endpointId: { eq: <id> }` filter to the `where` object."
  ENDPOINT_ID
  "Index by `status` field. Must supply an  `status: { eq: <status> }` filter to the `where` object."
  STATUS
}

input EndpointFilterInput {
  "Filter on the `endpointId` field. Required when using index `EndpointInded.ENDPOINT_ID`."
  endpointId: FilterValue
  "Filter on the `status` field. Only available when using index `EndpointIndex.STATUS`."
  status: FilterValue
}

"Fields to create a new endpoint."
input EndpointInput {
  "Unique identifier for the endpoint."
  endpointId: UUID!
  "Current status of the endpoint."
  status: EndpointStatus = ENABLED
  "The type of endpoint this endpoint is."
  endpointType: EndpointType = WEBHOOK
  "The url where this endpoint will transmit subscribed events to."
  url: String!
  """
  A list of subscriptions that are available, supporting wildcards `*`.

  Format: `<entity>.<inserted|updated|deleted>`
  Supported entities:
  - journal
  - account
  - accountcontext
  - accountset
  - accountsetmember
  - trancode
  - transaction
  - entry
  - balance
  - customindex
  - custombalance
  - endpoint
  """
  subscription: [String!]!
  "description of this endpoint."
  description: String!
  """
  Map of named CEL expressions specifying conditions for sending an event to the endpoint.

  Record is only sent if _all_ expressions evaluate to true, i.e. they are combined with a logical AND. Each expression must return a boolean value.
  """
  filters: ExpressionMap
}

"Fields to update an existing endpoint."
input EndpointUpdateInput {
  "Current status of the endpoint."
  status: EndpointStatus
  "The type of endpoint this endpoint is."
  endpointType: EndpointType
  "The url where this endpoint will transmit subscribed events to."
  url: String
  """
  A list of subscriptions that are available, supporting wildcards `*`.

  Format: `<entity>.<created|updated|deleted>`
  Supported entities:
  - journal
  - account
  - accountcontext
  - accountset
  - accountsetmember
  - trancode
  - transaction
  - entry
  - balance
  - customindex
  - custombalance
  - endpoint
  """
  subscription: [String]
  "description of this endpoint."
  description: String
  """
  Map of named CEL expressions specifying conditions for sending an event to the endpoint.

  Record is only sent if _all_ expressions evaluate to true, i.e. they are combined with a logical AND. Each expression must return a boolean value.
  """
  filters: ExpressionMap
}

enum EndpointStatus {
  ENABLED
  DISABLED
}

enum EndpointType {
  WEBHOOK
  ACH_PROCESSOR
}

extend type Mutation {
  files: FilesMutation!
}

extend type Query {
  files: FilesQuery!
}

type FilesMutation {
  "Create a file upload."
  createUpload(input: CreateUpload!): Upload @goField(forceResolver: true)
  "Create a link to download a file."
  createDownload(key: String!): Download @goField(forceResolver: true)
}

type FilesQuery {
  list(keyPrefix: String!): [String!] @goField(forceResolver: true)
}

type Download {
  "Unique identifier of file. e.g. `path/to/file.json`"
  key: String!
  "Presigned URL for downloading the file."
  downloadURL: String!
  "Timestamp of when presigned url expires."
  downloadURLExpiration: Timestamp!
  "Headers to include in the upload request."
  downloadHeaders: JSON!
  "`Content-Type` of the file."
  contentType: String!
}

type Upload {
  "Unique identifier of file. e.g. `path/to/file.json`"
  key: String!
  "Presigned URL for uploading the actual file."
  uploadURL: String!
  "Timestamp of when presigned url expires. If expired before file uploaded will need to create new upload."
  uploadURLExpiration: Timestamp!
  "Headers to include in the upload request."
  uploadHeaders: JSON!
  """
  `contentType` of file. Currently only type supported is `application/json`. File should be array of json objects to pass
  to bulk query as variables, each item in array representing a single
  execution of the query.
  """
  contentType: String!
}

input CreateUpload {
  "Unique identifier of file. e.g. `path/to/file.json`"
  key: String!
  """
  The type of upload:
  `BULK_GRAPHQL_VARIABLES` - The content-type is `application/json` and is an array of json objects for a bulk graphql query execution.
  `ACH` - The content-type is `text/plain` and is a NACHA formatted text file.
  """
  uploadType: UploadType! = BULK_GRAPHQL_VARIABLES
  """
  `contentType` of file.
  """
  contentType: String!
}

enum UploadType {
  BULK_GRAPHQL_VARIABLES
  ACH
}

extend type Mutation {
  iso8583: ISO8583Mutation!
}

extend type Query {
  iso8583: ISO8583Query!
}

type ISO8583Query {
  """
  Read an existing ISO8583 configuration.
  """
  config(
    """
    Unique identifier.
    @example("670504f6-0515-11f0-a441-069b540ea27c")
    """
    configId: UUID!
  ): ISO8583Config @goField(forceResolver: true)

  """
  List all ISO8583 configurations.
  """
  configs(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
    "Sort order for results."
    sort: SortOrder
  ): ISO8583ConfigConnection! @goField(forceResolver: true)
}

type ISO8583Mutation {
  """
  Create a configuration for ISO8583 processing. Defines settlement account, journal, and timezone.
  """
  createConfig(input: ISO8583CreateConfigInput!): ISO8583Config @goField(forceResolver: true)

  """
  Update configuration for ISO8583 processing.
  """
  updateConfig(configId: UUID!, input: ISO8583UpdateConfigInput!): ISO8583Config
    @goField(forceResolver: true)

  """
  Remove configuration.
  """
  deleteConfig(id: UUID!): ISO8583Config @goField(forceResolver: true)
}

input ISO8583UpdateConfigInput {
  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String

  """
  Balance to use for balance inquiry and partial authorizations.
  """
  openToBuyConfig: OpenToBuyConfigInput

  """
  Processor type for this configuration.
  """
  processor: ISO8583ProcessorType

  """
  Processor configuration.
  """
  processorSpec: JSON

  """
  Description of this configuration.
  """
  description: String
}

input ISO8583CreateConfigInput {
  """
  Unique identifier for this configuration.
  """
  configId: UUID!

  """
  Journal to post settlements into.
  """
  journalId: UUID!

  """
  ISO8583 Settlement Account.
  """
  settlementAccountId: UUID!

  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String!

  """
  Description of this configuration.
  """
  description: String

  """
  Processor type for this configuration.
  """
  processor: ISO8583ProcessorType!

  """
  Processor configuration.
  """
  processorSpec: JSON

  """
  Balance to use for balance inquiry and partial authorizations.
  """
  openToBuyConfig: OpenToBuyConfigInput
}

enum ISO8583ProcessorType {
  UNSPECIFIED
  VISA_DIRECT
  GALILEO
  MARQETA
  LITHIC
  HIGHNOTE
  Q2
  FIRST_DATA
  I2C
}

enum OpenToBuyType {
  "Available encumbrance balance in the normality of the account."
  AVAILABLE_ENCUMBRANCE
  "Available pending balance in the normality of the account."
  AVAILABLE_PENDING
  "Available settled balance in the normality of the account."
  AVAILABLE_SETTLED
  "A default windowed attached velocity control."
  VELOCITY_BALANCE
}

input OpenToBuyConfigInput {
  openToBuy: OpenToBuyType! = VELOCITY_BALANCE
}

type OpenToBuyConfig {
  openToBuy: OpenToBuyType!
}

type ISO8583Config implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `iso8583:config:<config_id>`.
  """
  id: ID!

  """
  Unique identifier for this configuration.
  """
  configId: UUID!

  """
  ISO8583 Settlement Account.
  """
  settlementAccountId: UUID!

  """
  Journal to post settlements into.
  """
  journalId: UUID!

  """
  IANA Timezone identifier for the configuration.
  @example("America/Chicago")
  """
  timeZone: String!

  """
  Description of this configuration.
  """
  description: String

  """
  Processor type for this configuration.
  """
  processor: ISO8583ProcessorType!

  """
  A moov iso8583 specification.  If not passed will use either the default
  I2C specification (for I2C users) or the ascii87 spec.
  """
  processorSpec: JSON

  """
  Which balance to use for balance inquiry or partial authorizations.
  """
  openToBuyConfig: OpenToBuyConfig!

  """
  Timestamp of when this configuration was created.
  """
  created: Timestamp!

  """
  Timestamp of the last modification to this configuration.
  """
  modified: Timestamp!

  _recordId: UUID!
  version: Int!

  """
  History of changes to this ISO8583 configuration.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): ISO8583ConfigHistoryConnection! @goField(forceResolver: true)
}

"""
Connection to a list of ISO8583 config nodes.
Access ISO8583 config nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type ISO8583ConfigConnection implements Connection {
  nodes: [ISO8583Config]!
  edges: [ISO8583ConfigConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of ISO8583 config nodes.
They contain a reference to the ISO8583 config node and metadata like the `cursor` position for the edge.
"""
type ISO8583ConfigConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the ISO8583 config node at this edge."
  node: ISO8583Config
}

"""
Connection to a list of ISO8583 config history nodes.
Access ISO8583 config history nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type ISO8583ConfigHistoryConnection implements Connection {
  nodes: [ISO8583Config]!
  edges: [ISO8583ConfigHistoryConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of ISO8583 config history nodes.
They contain a reference to the ISO8583 config history node and metadata like the `cursor` position for the edge.
"""
type ISO8583ConfigHistoryConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the ISO8583 config history node at this edge."
  node: ISO8583Config
}

extend type Query {
  "Get a single journal by its `journalId`. If `journalId` is omitted, return the default journal."
  journal("Unique identifier." id: UUID): Journal

  "Select one or more journals. Specify the index to use and apply filters to your query."
  journals(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: JournalIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: JournalFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): JournalConnection!
}

extend type Mutation {
  "Create a new journal for recording transactions in the ledger."
  createJournal(input: JournalInput!): Journal!

  "Update an existing journal. To ensure data integrity, only a subset of fields are allowed."
  updateJournal("Unique identifier." id: UUID!, input: JournalUpdateInput!): Journal!

  "Moves journal into `LOCKED` status. Prevents entries from being posted to the journal."
  deleteJournal("Unique identifier." id: UUID!): Journal
}

"""
Journals allow for the organizing of transactions within separate "books".

In many cases, users only need a single journal. For this reason, Twisp always contains a default journal with code `DEFAULT`.

Journals can be used for a variety of functions. For example, users may create separate journals for different currencies, or product-specific journals.
"""
type Journal implements Node{
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `jl:<key>` where `key` is `base64(json({ 1: journalId }))`.
  """
  id: ID!

  "Unique identifier for the journal."
  journalId: UUID!

  "Name for the journal."
  name: String!

  "Description of the journal."
  description: String!

  "Operational status of the journal. `ACTIVE` journals can be written to with `postTransaction`, whereas `LOCKED` journals do not allow transactions to be posted to them."
  status: Status!

  "Optional unique code for the journal. The default journal uses the code `DEFAULT`."
  code: String

  """
  Journal specific configuration options for transactions and balances
  recorded in this journal.
  """
  config: JournalConfig!

  "Date and time when the journal was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this journal. Previous versions are tracked in `history`."
  version: Int!

  _recordId: UUID!

  """
  History of changes to this Journal record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): JournalConnection! @goField(forceResolver: true)
}

"System configuration for a journal."
type JournalConfig {
  """
  When `true`, records point-in-time effective balances for all accounts in the journal.
  Defaults to `false`.
  """
  enableEffectiveBalances: Boolean!
}

"""
Connection to a list of Journal nodes.
Access Journal nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type JournalConnection implements Connection {
  nodes: [Journal]!
  edges: [JournalConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Journal nodes.
They contain a reference to the Journal node and metadata like the `cursor` position for the edge.
"""
type JournalConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Journal node at this edge."
  node: Journal
}

"Specify the pre-defined JournalIndex and sort order to use in a query."
input JournalIndexInput {
  name: JournalIndex!
  sort: SortOrder
}

"Indexes for querying Journals. To optimize query performance and apply desired filters, choose the appropriate index."
enum JournalIndex {
  "Index by `JOURNAL_ID` field. Must supply a `journalId: { eq: <id> }` filter to the `where` object."
  JOURNAL_ID
  "Index by `name` field. Use to apply query filters on the value of `name`."
  NAME
  "Index by `status` field. Use to apply query filters on the value of `status`."
  STATUS
  "Index by `code` field. Use to apply query filters on the value of `code`."
  CODE
}

"""
Filter conditions to apply to a journal query.
Filters are only applied if the field is used by the specified index.
"""
input JournalFilterInput {
  "Filter on the `journalId` field. Required when using index `JournalIndex.JOURNAL_ID`."
  journalId: FilterValue
  "Filter on the `name` field. Only available when using index `JournalIndex.NAME`."
  name: FilterValue
  "Filter on the `status` field. Only available when using index `JournalIndex.STATUS`."
  status: FilterValue
  "Filter on the `code` field. Only available when using index `JournalIndex.CODE`."
  code: FilterValue
}

"Fields to create a system configuration for a journal."
input JournalConfigInput {
  """
  When `true`, records point-in-time effective balances for all accounts in the journal.
  Defaults to `false`.
  """
  enableEffectiveBalances: Boolean
}

"Fields to create a new Journal."
input JournalInput {
  "Unique identifier for the journal."
  journalId: UUID!
  "Name for the journal."
  name: String!
  "Description of the journal."
  description: String
  "Operational status of the journal."
  status: Status! = ACTIVE
  "Optional unique code for the journal."
  code: String
  "System config for the journal."
  config: JournalConfigInput
}

"Journal fields to update."
input JournalUpdateInput {
  "Name for the journal."
  name: String
  "Description of the journal."
  description: String
  "Operational status of the journal."
  status: Status
  "The code used to refer to this journal."
  code: String
}

"Defines the rounding behavior when formatting units."
enum RoundingMode {
  "Rounds up if the next digit is > 5, otherwise rounds down."
  HALF_DOWN
  "Rounds up if the next digit is >= 5, otherwise rounds down."
  HALF_UP
  "Rounds towards 0, truncating extra digits."
  DOWN
  "Rounds away from 0."
  UP
}

"Defines how to render the currency indicator."
enum CurrencyDisplay {
  "Show the symbol for the currency. @example('$1.23') @example('1.23')"
  SYMBOL
  "Show the currency code. @example('USD') @example('EUR')"
  CODE
  "Don't show the code or symbol for the currency."
  NONE
}

"""
ISO 4217 standard three-character code indicating the currency. @example('USD') @example('CHF')
"""
scalar CurrencyCode

"""
Money type with multi-currency support.

Monetary amounts are represented as decimal units of currency. Fields which use the Money type can be converted to a symbolic representations by specifying a MoneyFormatInput on the `formatted` field.

Here is an example table showing different currencies which each have their own divisions of units represented. Japanese yen (JPY) don't have a decimal minor unit, and Bahraini dinars (BHD) use 3 minor unit decimal places. The `formatted` column uses the default values for a an `en-US` locale.

| Currency | Units    | Formatted |
|----------|----------|-----------|
| USD      | `289.27` | $289.27   |
| BHD      | `28.927` | 28.927 BD |
| JPY      | `28927`  | 28927    |
"""
type Money {
  units: Decimal!
  currency: CurrencyCode!
  formatted(as: MoneyFormatInput): String! @goField(forceResolver: true)
}

input MoneyInput {
  units: Decimal!
  currency: CurrencyCode!
}

# TODO: remove the "required" for all fields except locale, b/c they shouldn't be required if there is truly a default value
"""
Formatting options for money amounts.
"""
input MoneyFormatInput {
  "Locale represents a Unicode locale identifier. @example('de-DE') @example('hi-IN')"
  locale: String!
  "When true, whole digits will be grouped according to locale. For example, with locale `en-US` the number `1234567.89` is formatted with grouped digits as `1,234,567.89`. With other locales, these groupings may apply differently."
  groupDigits: Boolean! = false
  "When true, prefix the number with plus `+` symbol when the number is positive. Negative numbers are always displayed with a minus `-` symbol."
  addPlusSign: Boolean! = false
  "Defines the rounding behavior when the fractional units exceed the `maxDigits`."
  roundingMode: RoundingMode! = HALF_UP
  "Defines how to render the currency indicator."
  currencyDisplay: CurrencyDisplay! = SYMBOL
  "Minimum number of fractional digits. When not specified, it will use the default fractional digits for the currency. For example, USD amounts default to 2 minimum digits."
  minDigits: Int! = 255
  "Maximum number of fractional digits to show, which informs how rounding behavior is applied via the `roundingMode`. Defaults to 6."
  maxDigits: Int! = 6
}

extend type Mutation {
  queries: Query!
}

extend type Mutation {
  "Mutations in the `scheduler` namespace are used to manage scheduled jobs"
  scheduler: SchedulerMutation
}

type SchedulerMutation {
  createSchedule("Fields to create a new schedule." input: CreateScheduleInput!): Schedule @goField(forceResolver: true)
}

input CreateScheduleInput {
  """
  The job type to create the schedule for. Currently only one schedule
  per job-type is supported.
  """
  jobType: JobType!

  """
  A job name that's unique per job type.
  """
  jobName: String!

  """
  The Twisp principal to run the job on a schedule.
  This should have a matching `client` policy.
  """
  principal: String!

  """
  A schedule expression to run this job on.  cron/rate/once supported
  see https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html for valid syntax.
  """
  scheduleExpression: String!

  """
  The timezone to run this schedule on based on https://www.iana.org/time-zones

  example: "America/Los_Angeles" or "UTC"

  Supports ST rules defined in https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html
  """
  timezone: String!

  """
  JSON metadata to pass to running job.
  """
  metadata: JSON!
}

type Schedule {
   """
  The job type to create the schedule for. Currently only one schedule
  per job-type is supported.
  """
  jobType: JobType!

  """
  A job name that's unique per job type.
  """
  jobName: String!

  """
  The Twisp principal to run the job on a schedule.
  This should have a matching `client` policy.
  """
  principal: String!

  """
  A schedule expression to run this job on.  cron/rate/once supported
  see https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html for valid syntax.
  """
  scheduleExpression: String!

  """
  The timezone to run this schedule on based on https://www.iana.org/time-zones

  example: "America/Los_Angeles" or "UTC"

  Supports ST rules defined in https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html
  """
  timezone: String!

  """
  JSON metadata to pass to running job.
  """
  metadata: JSON!
}

enum JobType {
  SETTLE_WORKFLOW,
}

extend type Mutation {
  "Mutations in the `schema` namespace are used to manage custom indexes, aggregates, and historical indexes. Use the `schema` namespace to create and delete indexes and aggregates."
  schema: SchemaMutation!
}

extend type Query {
  "Queries in the `schema` namespace are used to retrieve information about custom indexes, aggregates, and historical indexes."
  schema: SchemaQuery!
}

type SchemaMutation {
  """
  Create a custom index for querying records. Currently available for indexing Account, AccountSet, Balance, Entry, Transaction, and TranCode record types.

  To query the index, use the `CUSTOM` index type for the applicable resource query and supply the filter inputs specified by the index.

  Custom indexes can be created using fields on the root level of the record like `Account.modified` as well as nested fields within documents like the `metadata` object.

  Depending on the parameters defined, custom indexes may be structured to return a single record or a sorted list of records.

  Note that due to the scaling properties of the underlying database, a single partition supports a fixed amount of read bandwidth and individual write operations per second. Beyond that threshold, throttling will occur. Visit scaling properties for more information.

  When designing custom indexes, care must be taken to ensure that reads and writes are spread across a sufficient number of partitions to support peak workloads. In practice, partitioning by account is usually sufficient. Our technical support staff is available for guidance on partition design patterns at [support@twisp.com](mailto:support@twisp.com).

  To learn more about indexes within the Twisp FLDB, see [Index-First Design](https://www.twisp.com/docs/infrastructure/ledger-database#index-first-design) in the docs.
  """
  createIndex(input: CreateIndexInput!): Index! @goField(forceResolver: true)

  """
  Create a custom index for querying all versions of records' histories.

  Because the Twisp FLDB is an [immutable, append-only data store](https://www.twisp.com/docs/infrastructure/ledger-database#append-only-immutability), changing the data within any record results in a new version of that record, leaving the original version intact in history.

  While regular indexes (such as those created by the `schema.createIndex` mutation) will index the most recent version of records, a historical index will index every version. This allows for defining sophisticated indexes to enable queries such as:

  - Retrieving account balances when the balance amount was negative.
  - Finding records' state when a particular value is set in their metadata.
  - Pulling time-delimited sets of balance activity.

  Partitions on historical indexes will by definition be larger than their equivalent partitions for regular indexes as they will contain not just the latest version of a record but also every previous version.
  """
  createHistoricalIndex(input: CreateIndexInput!): Index! @goField(forceResolver: true)

  """
  Create a search index for full text search support.

  Full text search indexes are powered by opensearch. These indexes are eventually consistent, but have the ability to
  execute complex queries utilizing the opensearch indexing engine.
  """
  createSearchIndex(input: CreateSearchIndexInput!): Index! @goField(forceResolver: true)

  "Update a search index"
  updateSearchIndex(
    name: String!
    on: IndexOnEnum!
    opensearchSchema: OpensearchSchemaInput!
  ): Index @goField(forceResolver: true)

  "Delete an existing index."
  deleteIndex(name: String!, on: IndexOnEnum!): Index @goField(forceResolver: true)

  """
  Create an view for a set of source tables.

  Views are materialized views that are defined by a CEL-expression map and get triggered by changes to one or more source tables.
  They allow for creating denormalized data structures that are automatically updated whenever source data changes.

  Each view has:
  - A document schema defined as a map of CEL expressions
  - Source table(s) that trigger updates to the view
  - Optional dimension(s) for partitioning and uniqueness constraints
  - Optional filters that determine when the view should be updated

  When source data changes, the view is automatically recalculated based on the provided CEL expressions.
  """
  createView(input: CreateViewInput!): View! @goField(forceResolver: true)

  "Delete an existing view."
  deleteView(name: String!): View @goField(forceResolver: true)
}

type SchemaQuery {
  "Get a single index by `name`."
  index(
    "Unique identifier of this index. Typically human readable."
    name: String!
    "The type of record this index applies to."
    on: IndexOnEnum!
  ): Index @goField(forceResolver: true)

  "List all indexes, ordered by `name`."
  indexes(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): IndexConnection! @goField(forceResolver: true)

  "Get a single view by `name`."
  view("Unique identifier of this view. Typically human readable." name: String!): View
    @goField(forceResolver: true)

  "List all views, ordered by `name`."
  views(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): ViewConnection! @goField(forceResolver: true)
}

input CreateIndexInput {
  "Unique identifier of this index. Typically human readable."
  name: String!

  "The type of record this index applies to."
  on: IndexOnEnum!

  "Indicates if this index is populated asynchronously."
  async: Boolean

  """
  Indicates if this index is a search index -- `unique`, `partition`
  and `sort` are ignored.
  """
  search: Boolean

  "Indicates if this index is unique."
  unique: Boolean

  "The partition key used for this index."
  partition: [PartitionKeyInput]!

  """
  Specifies the number of shards for partition write scaling.

  This parameter defines how many shards the partition key is
  automatically split into, similarly to RAID-style disk striping.
  Increasing this value allows the index to distribute write
  throughput across multiple shards while sacrificing global sort
  order on the partition.

  For instance, setting `partitionShardCount` to 4 splits each unique
  partition into four shards, effectively allowing 4000 writes per
  second for a single partition key.
  """
  partitionShardCount: Int

  "The sort key to use for supporting range queries."
  sort: [IndexKeyInput]!

  """
  Map of named CEL expressions specifying the conditions for including
  a record in this index.

  Records are only included in the index if _all_ expressions evaluate
  to `true`, i.e. they are combined with a logical AND. Each
  expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use
  the constraints `{ hasCategory: "has(document.metadata.category)" }`
  to ensure that only records whose `metadata` document has a defined
  value for the `category` field are included.
  """
  constraints: ExpressionMap
}

input CreateSearchIndexInput {
  "Unique identifier of this index. Typically human readable."
  name: String!

  "The type of record this index applies to."
  on: IndexOnEnum!

  """
  Map of named CEL expressions specifying the conditions for including a record in this index.

  Records are only included in the index if _all_ expressions evaluate to `true`, i.e. they are combined with a logical AND. Each expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use the constraints `{ hasCategory: "has(document.metadata.category)" }` to ensure that only records whose `metadata` document has a defined value for the `category` field are included.
  """
  constraints: ExpressionMap

  """
  The Opensearch CEL expression schema to apply to the document prior to indexing. Only available on search indexes.
  """
  opensearchSchema: OpensearchSchemaInput
}

"""
"""
type Index implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `ix:<key>` where `key` is `base64(json({ 1: name, 2: on }))`.
  """
  id: ID!

  "Unique identifier of this index. Typically human readable."
  name: String!

  "The type of record this index applies to."
  on: IndexOnEnum!

  "Indicates if this index is populated asynchronously."
  async: Boolean!

  "Indicates if this index is unique."
  unique: Boolean!

  "Indicates if this index is a search index."
  search: Boolean!

  "Indicates if this index is historical, i.e. created with `schema.createHistoricalIndex`."
  historical: Boolean!

  """
  For non-search indexes, the partition key used for this index.
  """
  partition: [PartitionKey]

  """
  For non-search indexes, the range key to use for query/sorting.
  """
  range: [IndexKey]

  """
  The Opensearch CEL expression schema to apply to the document prior to indexing.
  Only available on search indexes.
  """
  opensearchSchema: JSON

  """
  Map of named CEL expressions specifying the conditions for including a record in this index.

  Records are only included in the index if _all_ expressions evaluate to `true`, i.e. they are combined with a logical AND. Each expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use the constraints `{ hasCateogory: "has(document.metadata.category)" }` to ensure that only records whose `metadata` document has a defined value for the `category` field are included.
  """
  constraints: ExpressionMap

  """
  Twisp generated internal index identifier.
  """
  indexId: UUID!

  "The current version number of this index."
  version: Int!

  _recordId: UUID!
}

"""
Connection to a list of Index nodes.
Access Index nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type IndexConnection implements Connection {
  nodes: [Index]!
  edges: [IndexConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Index nodes.
They contain a reference to the Index node and metadata like the `cursor` position for the edge.
"""
type IndexConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Index node at this edge."
  node: Index
}

"""
Specify a named expression to sort the records within a custom index.

Used for sorting and for querying by range conditions.
"""
input IndexKeyInput {
  "Identifier for this key. Should be a short, human-readable name."
  alias: String!
  """
  CEL expression which resolves to the value that is to be sorted.

  Within the expression, the `document` object represents the record. To sort by a field on the record, use `document.<field_name>`.
  """
  value: Expression!
  "Whether the sort is in ascending or descending order."
  sort: SortOrder!

  """
  Optionally provide explicit type for value. Useful for metadata values which may be list of monomorphic types.

  @example("type: STRING")
  """
  type: IndexDataType
}

"A named expression used for sorting and range conditions."
type IndexKey {
  "Identifier for this key."
  alias: String!
  """
  CEL expression which resolves to the value that is to be sorted.

  Within the expression, the `document` object represents the record.
  """
  value: Expression!
  "Whether the sort is in ascending or descending order."
  sort: SortOrder!

  """
  Explicit type for sort key.
  """
  type: IndexDataType
}

"Specify a named expression to define a partition key."
input PartitionKeyInput {
  "Identifier for this partition key. Should be a short, human-readable name."
  alias: String!
  """
  CEL expression which resolves to the value that is to be used for the partition key.

  Within the expression, the `document` object represents the record. To access a field on the document, use `document.<field_name>`.
  """
  value: Expression!

  """
  Optionally provide explicit type for value. Useful for metadata values which may be list of monomorphic types.

  @example("type: STRING")
  """
  type: IndexDataType
}

"A named expression defining a partition key."
type PartitionKey {
  "Identifier for this partition key."
  alias: String!
  """
  CEL expression which resolves to the value that is to be used for the partition key.

  Within the expression, the `document` object represents the record.
  """
  value: Expression!

  """
  Resolved type of this partition element.
  """
  type: IndexDataType
}

"Record types which support custom indexes."
enum IndexOnEnum {
  Account
  AccountSet
  Balance
  Transaction
  TranCode
  Entry
}

"Query conditions for a custom index."
input CustomIndexFilter {
  "The `name` of the custom index to use."
  index: String!
  "Query conditions for specifying the index partition to use."
  partition: [CustomIndexFilterValue!]
  "Query conditions for specifying sort order."
  sort: [CustomIndexFilterValue!]
}

"Filter conditionals for querying the partition or sort key of a custom index."
input CustomIndexFilterValue {
  "Identifier for the key to apply the filter to."
  alias: String!
  "Conditions to apply at this key."
  value: FilterValue
}

input OpensearchSchemaInput {
  mappings: OpensearchSchemaObjectMappingInput!
}

input OpensearchSchemaMappingsInput {
  key: String!
  value: OpensearchSchemaMappingInput!
}

"""
Use one of `binaryType`, `numericType`, `booleanType`,`dateType`, `objectType` or `stringType`.
"""
input OpensearchSchemaMappingInput {
  binaryType: OpensearchSchemaBinaryMappingInput
  numericType: OpensearchSchemaNumericMappingInput
  booleanType: OpensearchSchemaBooleanMappingInput
  dateType: OpensearchSchemaDateMappingInput
  objectType: OpensearchSchemaObjectMappingInput
  stringType: OpensearchSchemaStringMappingInput
}

enum OpensearchSchemaBinaryMappingType {
  BINARY
}

input OpensearchSchemaBinaryMappingInput {
  type: OpensearchSchemaBinaryMappingType!
  """
  The CEL expression to index for the document.
  @example("document.is_void")
  """
  celExpression: Expression!
}

enum OpensearchSchemaNumericMappingType {
  BYTE
  DOUBLE
  FLOAT
  HALF_FLOAT
  INTEGER
  LONG
  UNSIGNED_LONG
  SHORT
}

input OpensearchSchemaNumericMappingInput {
  type: OpensearchSchemaNumericMappingType!
  """
  The CEL expression to index for the document.
  @example("document.amount.units()")
  """
  celExpression: Expression!
}

enum OpensearchSchemaBooleanMappingType {
  BOOLEAN
}

input OpensearchSchemaBooleanMappingInput {
  type: OpensearchSchemaBooleanMappingType!
  celExpression: Expression!
}

enum OpensearchSchemaDateMappingType {
  DATE
  DATE_NANOS
}

input OpensearchSchemaDateMappingInput {
  type: OpensearchSchemaDateMappingType!
  """
  The CEL expression to index for the document.
  @example("document.effective")
  """
  celExpression: Expression!
}

enum OpensearchSchemaObjectMappingType {
  OBJECT
}

input OpensearchSchemaObjectMappingInput {
  type: OpensearchSchemaObjectMappingType!
  properties: [OpensearchSchemaMappingsInput]
}

enum OpensearchSchemaStringMappingType {
  KEYWORD
  TEXT
  MATCH_ONLY_TEXT
  TOKEN_COUNT
  WILDCARD
}

input OpensearchSchemaStringMappingInput {
  type: OpensearchSchemaStringMappingType!
  """
  The CEL expression to index for the document.
  @example("document.description")
  """
  celExpression: Expression!
  """
  Provide multi-field mappings for this field.
  """
  fields: [OpensearchSchemaMultiFieldsInput!]
}

input OpensearchSchemaStringMultiFieldInput {
  type: OpensearchSchemaStringMappingType!
}

input OpensearchSchemaMultiFieldsInput {
  key: String!
  value: OpensearchSchemaMultiFieldInput!
}

input OpensearchSchemaMultiFieldInput {
  stringType: OpensearchSchemaStringMultiFieldInput
}

"""
Input for creating a new view materialized view.
"""
input CreateViewInput {
  """
  Unique identifier of this view. Will be used as the table name in the public namespace.
  Should be a short, human-readable name.
  """
  name: String!

  """
  Cel Expressions and Type that define the aggregation.

  `context.source` will have the triggering document.
  """
  document: [DocumentElementInput!]!

  """
  List of source tables that trigger updates to this view.
  When records in these tables are inserted, updated, or deleted, the view will be recalculated.
  """
  sources: [ViewSourceInput!]!

  """
  Partition for this aggregation.

  Use `context.source` for defining the index.
  """
  partition: [PartitionKeyInput!]!

  """
  Sort for this aggregation.

  Use `context.source` for defining the index.
  """
  sort: [IndexKeyInput!]!

  """
  Map of named CEL expressions that filter when the view should be updated.
  Only source changes that satisfy all filter conditions will trigger an update to the view.
  Each expression must return a boolean value.

  Default: { enabled: "true" } (all changes trigger an update)
  """
  filters: ExpressionMap

  """
  Human readable description of this view.
  """
  description: String! = ""

  """
  Extra config options for view.
  """
  config: ViewConfigInput

  """
  A CEL expression to normalize the source object by.
  If provided, must evaluate to a list. The trigger will be repeated for
  each item in the list and the value will be available on `context.trigger.normalize`.

  If evaluates to an empty list, will behave as if the normalize expression not provided.
  """
  normalize: Expression

  indexes: [ViewIndexInput!]

  searchIndexes: [ViewSearchIndexInput!]
}

enum ViewTriggerEnum {
  OnSelect
  OnInsert
  OnUpdate
  OnDelete
}

"""
Enum of source tables that can trigger view updates.
"""
enum ViewEntity {
  Account
  AccountSet
  Balance
  Entry
  Transaction
  TranCode
}

input ViewSourceInput {
  entity: ViewEntity!
  triggers: [ViewTriggerEnum!]!
}

type ViewSource {
  entity: ViewEntity!
  triggers: [ViewTriggerEnum!]!
}

"""
Filter input for querying view entries.
"""
input ViewFilter {
  """
  Use the index filter for standard index queries.
  """
  index: ViewIndexFilter
  """
  Use the search filter for search index queries.
  """
  search: SearchFilter
}

input ViewIndexFilter {
  """
  Name of the index to use. If not provided, the standard index is queried.
  """
  index: String
  """
  Specify the partition of view index.
  """
  partition: [CustomIndexFilterValue!]

  """
  Speficy the sort of the view index.
  """
  sort: [CustomIndexFilterValue!]
}

"""
Represents an view materialized view.
"""
type View implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `ag:<name>`.
  """
  id: ID!

  """
  Unique identifier of this view. Typically human readable.
  """
  name: String!

  """
  The document produced by this view.
  """
  document: [DocumentElement!]!

  """
  List of source tables that trigger updates to this view.
  """
  sources: [ViewSource!]!

  """
  Dimensions define the partition for the view.
  """
  partition: [PartitionKey!]!

  "The sort key to use for supporting range queries."
  sort: [IndexKey!]!

  """
  Filters that determine when the view should be updated.
  Only source changes that satisfy these conditions will trigger an update.
  """
  filters: ExpressionMap

  #
  """
  Human readable description of this view.
  """
  description: String

  #
  """
  Creation timestamp of this view.
  """
  created: Timestamp!

  #
  """
  Lat modified timestamp of this view.
  """
  modified: Timestamp!

  #
  """
  Configuration including concurrent enablement.
  """
  config: ViewConfig!
  """
  Twisp generated internal view identifier.
  """
  viewId: UUID!

  """
  Expression that this view is normalized by.
  """
  normalize: Expression

  indexes: [ViewIndex!]

  searchIndexes: [ViewSearchIndex!]

  """
  The current version number of this view.
  """
  version: Int!

  _recordId: UUID!
}

"""
Connection to a list of View nodes.
Access View nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type ViewConnection implements Connection {
  nodes: [View]!
  edges: [ViewConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of View nodes.
They contain a reference to the View node and metadata like the `cursor` position for the edge.
"""
type ViewConnectionEdge {
  """
  Cursor position at this edge.
  """
  cursor: String!

  """
  Reference to the View node at this edge.
  """
  node: View
}

type ViewConfig {
  enableConcurrentPosting: Boolean!
}

input ViewConfigInput {
  enableConcurrentPosting: Boolean! = true
}

type ViewIndex {
  """
  Twisp generated internal index identifier.
  """
  indexId: UUID!

  "Unique identifier of this index. Typically human readable."
  name: String!

  "Indicates if this index is unique."
  unique: Boolean

  "The partition key used for this index."
  partition: [PartitionKey]!

  """
  Specifies the number of shards for partition write scaling.

  This parameter defines how many shards the partition key is
  automatically split into, similarly to RAID-style disk striping.
  Increasing this value allows the index to distribute write
  throughput across multiple shards while sacrificing global sort
  order on the partition.

  For instance, setting `partitionShardCount` to 4 splits each unique
  partition into four shards, effectively allowing 4000 writes per
  second for a single partition key.
  """
  partitionShardCount: Int

  "The sort key to use for supporting range queries."
  sort: [IndexKey]!

  """
  Map of named CEL expressions specifying the conditions for including
  a record in this index.

  Records are only included in the index if _all_ expressions evaluate
  to `true`, i.e. they are combined with a logical AND. Each
  expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use
  the constraints `{ hasCategory: "has(document.metadata.category)" }`
  to ensure that only records whose `metadata` document has a defined
  value for the `category` field are included.
  """
  constraints: ExpressionMap
}

input ViewIndexInput {
  "Unique identifier of this index. Typically human readable."
  name: String!

  "Indicates if this index is unique."
  unique: Boolean

  "The partition key used for this index."
  partition: [PartitionKeyInput]!

  """
  Specifies the number of shards for partition write scaling.

  This parameter defines how many shards the partition key is
  automatically split into, similarly to RAID-style disk striping.
  Increasing this value allows the index to distribute write
  throughput across multiple shards while sacrificing global sort
  order on the partition.

  For instance, setting `partitionShardCount` to 4 splits each unique
  partition into four shards, effectively allowing 4000 writes per
  second for a single partition key.
  """
  partitionShardCount: Int

  "The sort key to use for supporting range queries."
  sort: [IndexKeyInput]!

  """
  Map of named CEL expressions specifying the conditions for including
  a record in this index.

  Records are only included in the index if _all_ expressions evaluate
  to `true`, i.e. they are combined with a logical AND. Each
  expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use
  the constraints `{ hasCategory: "has(document.metadata.category)" }`
  to ensure that only records whose `metadata` document has a defined
  value for the `category` field are included.
  """
  constraints: ExpressionMap
}

type ViewSearchIndex {
  """
  Twisp generated internal index identifier.
  """
  indexId: UUID!

  "Unique identifier of this index. Typically human readable."
  name: String!

  """
  Map of named CEL expressions specifying the conditions for including a record in this index.

  Records are only included in the index if _all_ expressions evaluate to `true`, i.e. they are combined with a logical AND. Each expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use the constraints `{ hasCategory: "has(document.metadata.category)" }` to ensure that only records whose `metadata` document has a defined value for the `category` field are included.
  """
  constraints: ExpressionMap

  """
  The Opensearch CEL expression schema to apply to the document prior to indexing. Only available on search indexes.
  """
  opensearchSchema: JSON!
}

input ViewSearchIndexInput {
  "Unique identifier of this index. Typically human readable."
  name: String!

  """
  Map of named CEL expressions specifying the conditions for including a record in this index.

  Records are only included in the index if _all_ expressions evaluate to `true`, i.e. they are combined with a logical AND. Each expression must return a boolean value.

  For example, a custom index on a `metadata.category` field might use the constraints `{ hasCategory: "has(document.metadata.category)" }` to ensure that only records whose `metadata` document has a defined value for the `category` field are included.
  """
  constraints: ExpressionMap

  """
  The Opensearch CEL expression schema to apply to the document prior to indexing. Only available on search indexes.
  """
  opensearchSchema: OpensearchSchemaInput!
}

extend type Query {
  "Get a single tran code by its `tranCodeId`."
  tranCode("Unique identifier." id: UUID!): TranCode

  "Select one or more tran codes. Specify the index to use and apply filters to your query."
  tranCodes(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: TranCodeIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: TranCodeFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TranCodeConnection!
}

extend type Mutation {
  "Create a new transaction code (tran code)."
  createTranCode(input: TranCodeInput!): TranCode!

  "Update an existing tran code. To ensure data integrity, only a subset of fields are allowed."
  updateTranCode("Unique identifier." id: UUID!, input: TranCodeUpdateInput!): TranCode!

  "Moves the tran code into `LOCKED` status. Prevents transactions from posting using this version of tran code."
  deleteTranCode("Unique identifier." id: UUID!): TranCode
}

"""
Transaction Codes (tran codes) are how financial engineers do double-entry accounting. They encode the basic patterns for a type of transaction as a predictable and repeatable formula.

You can think of tran codes as function signatures which define how a transaction acts upon the ledger.
"""
type TranCode implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `tc:<key>` where `key` is `base64(json({ 1: tranCodeId }))`.
  """
  id: ID!

  "Internal UUID for the transaction code record."
  tranCodeId: UUID!

  """
  The tran code represented as a unique string identifier.

  The code itself is a shorthand for the behavior represented. For example, the code `ACH_CREDIT` may represent a transaction writing two entries: an `ACH_DR` entry and an `ACH_CR` entry.
  """
  code: String!

  "Explanation of what this tran code represents and how it should be used. This provides documentation for the tran code."
  description: String!

  "Defines the parameters that can be used when posting transactions using this tran code."
  params: [ParamDefinition]

  "Definition of the transaction posted when this tran code is invoked."
  transaction: TranCodeTransaction!

  "Definition of the entries written when transactions are posted with this tran code."
  entries: [TranCodeEntry!]!

  # TODO: add LOCKED status with message "To avoid rewriting accounting history, tran codes should never be deleted but simply marked 'LOCKED'."
  "Operational status of the tran code."
  status: Status!

  "Metadata attached to this tran code."
  metadata: JSON

  """
  CEL expressions that are evaluated before transaction and entries and can be used a scratch pad area.
  """
  vars: ExpressionNestedMap

  "Workflow execution definition triggered when this tran code is invoked."
  workflow: TranCodeWorkflow

  "Date and time when the tran code was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "The current version number of this account. Previous versions are tracked in `history`."
  version: Int!

  _recordId: UUID!

  """
  History of changes to this TranCode record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TranCodeConnection! @goField(forceResolver: true)
}

"""
Definition of a parameter that can be used when posting transactions using this tran code.

These definitions are used to validate the provided `params` in a TransactionInput to ensure that only the right data is applied to the entries created.

With CEL, you can access the post-time values of these parameters inside of values in `transaction` and `entries`.
"""
type ParamDefinition {
  """
  Name for the parameter.
  This is how values passed are accessed. For example, a parameter with name `fromAccount` can be accessed in the `accountId` field of an TranCodeEntryInput with `params.fromAccount`.
  """
  name: String!
  "Data type for the parameter."
  type: ParamDataType!
  """
  Default value for the parameter.
  If not provided, the parameter is consider a 'required' parameter, and a value must be provided when posting a transaction.
  """
  default: Expression
  "Describe the purpose of this parameter. Help an engineer out."
  description: String
}

"Definition of the transaction posted when this tran code is invoked."
type TranCodeTransaction {
  "Effective date for transactions posted with this tran code."
  effective: Expression!

  "Journal ID for transactions posted with this tran code."
  journalId: Expression!

  "Correlation ID for transactions posted with this tran code."
  correlationId: Expression

  "External ID for transactions posted with this tran code."
  externalId: Expression

  "Description for transactions posted with this tran code."
  description: Expression!

  "Metadata for transactions posted with this tran code."
  metadata: Expression!
}

"Definition of an entry written when transactions are posted with this tran code."
type TranCodeEntry {
  "Entry type for an entry written when this tran code is invoked."
  entryType: Expression!

  "Account ID for an entry written when this tran code is invoked."
  accountId: Expression!

  "Layer for an entry written when this tran code is invoked."
  layer: Expression!

  "Direction for an entry written when this tran code is invoked."
  direction: Expression!

  "Units of currency for an entry written when this tran code is invoked."
  units: Expression!

  "Currency used for an entry written when this tran code is invoked."
  currency: Expression!

  "Description for an entry written when this tran code is invoked."
  description: Expression

  "Metadata for entries posted with this tran code."
  metadata: Expression

  """
  A boolean expression that indicates if this entry should be written.
  @example("params.amount > decimal(0.00)")
  """
  condition: Expression
}

"""
Connection to a list of TranCode nodes.
Access TranCode nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type TranCodeConnection implements Connection {
  nodes: [TranCode]!
  edges: [TranCodeConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of TranCode nodes.
They contain a reference to the TranCode node and metadata like the `cursor` position for the edge.
"""
type TranCodeConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the TranCode node at this edge."
  node: TranCode
}

"Specify the pre-defined TranCodeIndex and sort order to use in a query."
input TranCodeIndexInput {
  name: TranCodeIndex!
  sort: SortOrder
}

"Indexes for querying TranCodes. To optimize query performance and apply desired filters, choose the appropriate index."
enum TranCodeIndex {
  "Index by `tranCodeId` field. Must supply a `tranCodeId: { eq: <id> }` filter to the `where` object."
  TRAN_CODE_ID
  "Index by `code` field. Use to apply query filters on the value of `code`."
  CODE
  "Index by `status` field. Use to apply query filters on the value of `status`."
  STATUS
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
}

"""
Filter conditions to apply to a tran code query.
Filters are only applied if the field is used by the specified index.
"""
input TranCodeFilterInput {
  "Filter on the `tranCodeId` field. Required when using index `TranCodeIndex.TRAN_CODE_ID`."
  tranCodeId: FilterValue
  "Filter on the `code` field. Only available when using index `TranCodeIndex.CODE`."
  code: FilterValue
  "Filter on the `status` field. Only available when using index `TranCodeIndex.STATUS`."
  status: FilterValue
  "Filter conditions for a custom index. Only available when using index `TranCodeIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `TranCodeIndex.SEARCH`."
  search: SearchFilter
}

"Fields to create a new TranCode."
input TranCodeInput {
  "Internal UUID for the transaction code record."
  tranCodeId: UUID!
  "The tran code represented as a unique string identifier. @example('ACH_CREDIT')"
  code: String!
  "Explanation of what this tran code represents and how it should be used. This provides documentation for the tran code."
  description: String
  "Define the parameters that can be used when posting transactions using this tran code."
  params: [ParamDefinitionInput!]
  "Define the values for the transaction posted when this tran code is invoked."
  transaction: TranCodeTransactionInput!
  "Define the values of entries written when transactions are posted with this tran code."
  entries: [TranCodeEntryInput!]!
  "Metadata attached to this tran code."
  metadata: JSON
  "Calculation area evaluated and injected as `vars` for transaction and entry evaluation."
  vars: ExpressionNestedMap
  "Workflow execution to trigger when transactions are posted with this tran code."
  workflow: TranCodeWorkflowInput
}

"""
Define a parameter that can be used when posting transactions using this tran code.
"""
input ParamDefinitionInput {
  """
  Name for the parameter.
  This is how values passed are accessed. For example, a parameter with name `fromAccount` can be accessed in the `accountId` field of an TranCodeEntryInput with `params.fromAccount`.
  """
  name: String!
  "Data type for the parameter."
  type: ParamDataType! = STRING
  """
  Default value for the parameter.
  If not provided, the parameter is consider a 'required' parameter, and a value must be provided when posting a transaction.
  """
  default: Expression
  "Describe the purpose of this parameter. Help an engineer out."
  description: String
}

"Define the values for the transaction posted when this tran code is invoked."
input TranCodeTransactionInput {
  """
  Effective date for the transaction posted with this tran code.
  If ommitted, defaults to `date.Today()`.
  Expression must be a valid ISO 8601 formatted date.
  @example("date('2022-12-23')")
  """
  effective: Expression

  """
  Journal ID for the transaction posted with this tran code.
  If omitted, the default journal will be used.
  Expression must resolve to a UUID type.
  @example("uuid('b28f5684-0834-4292-8016-d2f2fb0367a9')")
  """
  journalId: Expression

  """
  Correlation ID for the transaction posted with this tran code.
  Expression must resolve to a String type.
  @example("'5a028997'")
  """
  correlationId: Expression

  """
  External ID for the transaction posted with this tran code.
  Expression must resolve to a String type.
  @example("'45415819'")
  """
  externalId: Expression

  """
  Description for the transaction posted with this tran code.
  Expression must resolve to a String type.
  @example("'TX for ' + string(params.amount)")
  """
  description: Expression

  """
  Metadata for the transaction posted with this tran code.
  Expression must resolve to a JSON type.
  @example("{ 'x': 1, 'y': { 'z': 2 }}")
  """
  metadata: Expression
}

"Defines the values for the entries written when transactions are posted with this tran code."
input TranCodeEntryInput {
  """
  Account ID for an entry written when this tran code is invoked.
  Expression must resolve to a UUID type.
  """
  accountId: Expression!

  """
  Units of currency for an entry written when this tran code is invoked.
  Expression must resolve to a Decimal type.
  """
  units: Expression!

  """
  Currency used for an entry written when this tran code is invoked.
  Expression must resolve to a CurrencyCode type.
  """
  currency: Expression!

  """
  Direction for an entry written when this tran code is invoked.
  Expression must resolve to a DebitOrCredit enum type.
  """
  direction: Expression!

  """
  Entry type for an entry written when this tran code is invoked.
  If omitted, defaults to `tranCode.code` with `_CR` or `_DR` appended depending on entry `direction`.
  Expression must resolve to a String type.
  """
  entryType: Expression

  """
  Layer for an entry written when this tran code is invoked.
  If omitted, defaults to `SETTLED` layer.
  Expression must resolve to a Layer enum type.
  """
  layer: Expression

  """
  Description for an entry written when this tran code is invoked."
  Expression must resolve to a String type.
  """
  description: Expression

  """
  Metadata for the entry posted with this tran code.
  Expression must resolve to a JSON type.
  @example("{ 'x': 1, 'y': { 'z': 2 }}")
  """
  metadata: Expression

  """
  A boolean expression that indicates if this entry should be written.
  @example("params.amount > 0")
  """
  condition: Expression
}

"Definition for workflow execution triggered by a tran code."
type TranCodeWorkflow {
  "CEL expression that evaluates to the workflow ID (UUID)."
  workflowId: Expression!
  "CEL expression that evaluates to the execution ID (UUID)."
  executionId: Expression!
  "CEL expression that evaluates to the task name (String)."
  task: Expression!
  "Map of param names to CEL expressions for workflow params."
  params: ExpressionMap
}

"Input for workflow execution in tran code definition."
input TranCodeWorkflowInput {
  "CEL expression for workflow ID."
  workflowId: Expression!
  "CEL expression for execution ID."
  executionId: Expression!
  "CEL expression for task name."
  task: Expression!
  "CEL expressions for workflow params."
  params: ExpressionMap
}

"TranCode fields to update."
input TranCodeUpdateInput {
  "Explanation of what this tran code represents and how it should be used. This provides documentation for the tran code."
  description: String
  """
  Define the parameters that can be used when posting transactions using this tran code.
  Replaces existing parameters definition.
  """
  params: [ParamDefinitionInput!]
  """
  Define values for transaction posted when this tran code is invoked.
  Replaces existing transaction definition.
  """
  transaction: TranCodeTransactionInput
  """
  Define the values of entries written when transactions are posted with this tran code.
  Replaces existing entry definition.
  """
  entries: [TranCodeEntryInput!]
  "Operational status of the tran code."
  status: Status
  "Metadata attached to this tran code."
  metadata: JSON
  "Variables for computation."
  vars: ExpressionNestedMap
  "Workflow execution to trigger when transactions are posted with this tran code."
  workflow: TranCodeWorkflowInput
}

extend type Query {
  "Get a single transaction by its `transactionId`."
  transaction("Unique identifier." id: UUID!): Transaction

  "Select one or more transactions. Specify the index to use and apply filters to your query."
  transactions(
    """
    Select from a list of pre-defined indexes. For optimal performance, choose specific indexes on unique fields over more general ones.
    """
    index: TransactionIndexInput!
    """
    Filter the query according to specified conditions. Depending on the index chosen, different filters will be allowed.
    """
    where: TransactionFilterInput
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TransactionConnection!
}

extend type Mutation {
  "Write a transaction to the ledger using the predefined defaults from the `tranCode` provided."
  postTransaction(input: TransactionInput!): Transaction!

  "Update an existing transaction. To ensure data integrity, only a subset of fields are allowed."
  updateTransaction("Unique identifier." id: UUID!, input: TransactionUpdateInput!): Transaction!

  "Void an existing transaction."
  voidTransaction("Unique identifier." id: UUID!): Transaction!
}

"""
Transactions record all accounting events in the ledger. In Twisp, the only way to write to a ledger is through a transaction.

Every transaction writes two or more entries to the ledger in standard double-entry accounting practice.

Twisp expands upon the basic principle of an accounting transaction with additional features like transaction codes and correlations.
"""
type Transaction implements Node {
  """
  Globally unique identifier for a record to support Global Object Identification.
  Uses format `tx:<key>` where `key` is `base64(json({ 1: transactionId }))`.
  """
  id: ID!
  "Unique identifier for the transaction."
  transactionId: UUID!

  "Unique identifier for the tran code used by this transaction."
  tranCodeId: UUID!

  "Unique identifier for the journal this transaction applies to."
  journalId: UUID!

  """
  Allows related transactions to be grouped.

  When a transaction is posted without a `correlationId`, it uses the `transactionId` as the `correlationId`. Then, future related transactions can be posted with the same `correlationId` to indicate their relationship to the original. This is very useful for events like holds, auths, auth reversals, etc.

  For example, consider the following (simplified) list of transactions:

  (ID: 1) Place card hold for $50 on account A (correlation ID: 1)
  (ID: 2) Place card hold for $20 on account B (correlation ID: 2)
  (ID: 3) Release card hold for $50 on account A (correlation ID: 1)

  Because transaction (3) is _related_ to transaction (1), it shares the same correlation ID. This way, we can easily observe the entire history of a multi-transaction event by querying the correlated transactions.
  """
  correlationId: String!

  "Allows specifying a unique external ID associated with this transaction."
  externalId: String!

  "The effective date records when the transaction is recorded as occurring for accounting purposes. Determines the accounting period within which the transaction is counted."
  effective: Date!

  "Description of the transaction."
  description: String!

  "Arbitrary structured data about this transaction."
  metadata: JSON

  "The voided by records the transaction identifier that voided this transaction."
  voidedBy: UUID

  "The void of records the transaction identifier this transaction is voiding"
  voidOf: UUID

  "Date and time when the transaction was first posted."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  properties: TransactionProperties!

  "The current version number of this transaction. Previous versions are tracked in `history`."
  version: Int!

  _recordId: UUID!

  "List of all correlated transactions. These are transactions which share the same `correlationId`."
  correlated(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TransactionConnection! @goField(forceResolver: true)

  "Ledger entries written by the transaction."
  entries(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): EntryConnection! @goField(forceResolver: true)

  """
  History of changes to this Transaction record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): TransactionConnection! @goField(forceResolver: true)

  "Reference to the journal this transaction applies to."
  journal: Journal! @goField(forceResolver: true)

  "Reference to the tran code used by this transaction."
  tranCode: TranCode! @goField(forceResolver: true)

  "Reference to any exceptions, if occurred."
  exceptions: [TransactionException!] @goField(forceResolver: true)

  "Look up the workflow executions that produced this transaction."
  workflows(
    "Return workflow executions for all versions of this transaction"
    all: Boolean = false
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): WorkflowExecutionConnection @goField(forceResolver: true)
}

type TransactionProperties {
  """
  Overrides velocity enforcements that have an action of `VOID` or `REJECT`.
  Useful for forced postings that require disabled velocity control enforcement (e.g. set to `WARN`).
  """
  overrideVelocityEnforcement: VelocityEnforcement
}

type TransactionException {
  type: String!
  message: String!
  detail: JSON!
}

"""
Connection to a list of Transaction nodes.
Access Transaction nodes directly through the `nodes` field, or access information about the connection edges with the `edges` field.
Use `pageInfo` to paginate responses using the cursors provided.
"""
type TransactionConnection implements Connection {
  nodes: [Transaction]!
  edges: [TransactionConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of Transaction nodes.
They contain a reference to the Transaction node and metadata like the `cursor` position for the edge.
"""
type TransactionConnectionEdge {
  "Cursor position at this edge."
  cursor: String!
  "Reference to the Transaction node at this edge."
  node: Transaction
}

"Specify the pre-defined TransactionIndex and sort order to use in a query."
input TransactionIndexInput {
  name: TransactionIndex!
  sort: SortOrder
}

"Indexes for querying Transactions. To optimize query performance and apply desired filters, choose the appropriate index."
enum TransactionIndex {
  "Index by `TRANSACTION_ID` field. Must supply a `transactionId: { eq: <id> }` filter to the `where` object."
  TRANSACTION_ID
  "Index by `CORRELATION_ID` field. Must supply a `correlationId: { eq: <id> }` filter to the `where` object."
  CORRELATION_ID
  "Index by `EXTERNAL_ID` field. Must supply an `externalId: { eq: <id> }` filter to the `where` object."
  EXTERNAL_ID
  "Use a custom-defined index. Must supply a `custom` filter to the `where` object."
  CUSTOM
  "Use eventually consisent search. Must supply a `search` filter to the `where` object."
  SEARCH
  "Retrieve a list of transactions by id. Must supply an `ids` filter to the `where` object."
  TRANSACTION_IDS
  "Retrieve a list of transactions by group. Must supply a `group` filter to the `where` object."
  GROUP
}

"""
Filter conditions to apply to a transaction query.
Filters are only applied if the field is used by the specified index.
"""
input TransactionFilterInput {
  "Specify the Journal to use with `eq`. If omitted, the default journal will be used."
  journalId: FilterValue
  "Filter on the `transactionId` field. Required when using index `TransactionIndex.TRANSACTION_ID`."
  transactionId: FilterValue
  "Filter on the `correlationId` field. Required when using index `TransactionIndex.CORRELATION_ID`."
  correlationId: FilterValue
  "Filter on the `externalId` field. Required when using index `TransactionIndex.EXTERNAL_ID`."
  externalId: FilterValue
  "Filter on the `group` field. Required when using index `TransactionIndex.GROUP`."
  group: FilterValue
  "Filter conditions for a custom index. Only available when using index `TransactionIndex.CUSTOM`."
  custom: CustomIndexFilter
  "Filter conditions for a search.  Only available when using index `TransactionIndex.SEARCH`."
  search: SearchFilter
  "Retrieve up to 100 transactions by id."
  transactionIds: [UUID!]
}

"Fields to post a new Transaction."
input TransactionInput {
  "The ID is required to ensure an idempotent transaction."
  transactionId: UUID!
  "String corresponding to the `code` of a TranCode to be used for this transaction."
  tranCode: String!
  """
  Version of the tran code to use in this transaction.
  If not supplied, the latest version will be used.
  """
  tranCodeVersion: Int
  "Params object specifying values for the params defined in the corresponding TranCode."
  params: JSON
  """
  Set various transaction properties, including changing velocity enforcement.
  """
  properties: TransactionPropertiesInput
}

input TransactionPropertiesInput {
  """
  Override velocity enforcement for this request. If a velocity control action will enforce at
  `VOID` or `REJECT`, will enforce with the action specified in this request.

  This is useful for force posts, where you want to disable a velocity control with an action of `WARN`.
  """
  overrideVelocityEnforcement: VelocityEnforcementInput

  """
  If provided, will post transaction and immediately void. Will also create the transaction
  exception provided that is returned on `Transaction.exceptions`.  Using this option will
  automatically set the `overrideVelocityEnforcement.action` to `WARN`, allowing all
  velocity controls to evaluate and write exceptions at WARN level.
  """
  exception: TransactionExceptionInput
}

input TransactionExceptionInput {
  """
  Human readable code that describes the type of exception.

  @example("FRAUD")
  """
  type: String!

  """
  Human readable message that gives contextual detail about why this exception has occurred.

  @example("fraud system indicated 95% chance of fraud")
  """
  message: String!
  """
  Arbitrary structured data about this particular exception.
  """
  detail: JSON!
}

"Transaction fields to update."
input TransactionUpdateInput {
  "Allows specifying a unique external ID associated with this transaction."
  externalId: String
  "Description of the transaction."
  description: String
  "Arbitrary structured data about this transaction."
  metadata: JSON
}

extend type Query {
  # Apply a set of rules to an account or set.
  velocityControl(id: UUID!): VelocityControl
  velocityControls(
    index: VelocityControlIndexInput!
    where: VelocityControlFilterInput
    first: Int! = 100
    after: String
  ): VelocityControlConnection

  # Velocity Limits.
  velocityLimit(id: UUID!): VelocityLimit
  velocityLimits(
    index: VelocityLimitIndexInput!
    where: VelocityLimitFilterInput
    first: Int! = 100
    after: String
  ): VelocityLimitConnection

  """
  Search for the velocity balance for an Account or Account Set.
  """
  velocity(
    "Account or Account Set to search for velocity."
    accountId: UUID!
    """
    The window of the balance to look up. If
    `velocityLimitId` not provided, will look up
    all velocity limits that support the defined
    window.
    @example({year: "2022", month:"9"})
    """
    window: JSON!
    "The currency for the velocity to look up."
    currency: CurrencyCode! = "USD"
    "If provided, retrieve this specific velocity limit."
    velocityLimitId: UUID
    "If provided, retrieve from specified journal. Otherwise will use default."
    journalId: UUID
  ): [VelocityBalance]

  """
  List all velocity controls attached the specified Account or Account Set.
  """
  attachedControls(
    "Account or Account Set Id to look up attached controls"
    accountId: UUID!
    first: Int!
    after: String! = ""
  ): ResolvedVelocityControlConnection! @goField(forceResolver: true)
}

extend type Mutation {
  createVelocityControl(input: VelocityControlInput!): VelocityControl!
  updateVelocityControl(
    velocityControlId: UUID!
    input: UpdateVelocityControlInput!
  ): VelocityControl
  deleteVelocityControl(velocityControlId: UUID!): VelocityControl

  createVelocityLimit(input: VelocityLimitInput!): VelocityLimit!
  updateVelocityLimit(velocityLimitId: UUID!, input: UpdateVelocityLimitInput!): VelocityLimit
  deleteVelocityLimit(velocityLimitId: UUID!): VelocityLimit

  """
  Attach an account or set to the control.
  """
  attachVelocityControl(
    "The control to attach account limit to."
    velocityControlId: UUID!
    """
    Account or Set Id to attach to the velocity control to.
    """
    accountId: UUID!
    """
    Journal on which journal to attach the velocity control to.
    Attaches to the default journal if not provided.
    """
    journalId: UUID
    """
    The parameters for the velocity limit to use.
    If attaching for default limits for control (`velocityLimitId == null`),
    Then params must satify all defined params on defualt limits
    """
    params: JSON
  ): VelocityControl

  """
  detach account from control.
  """
  detachVelocityControl(
    "The Velocity Control to detach."
    velocityControlId: UUID!
    "The account id detaching from."
    accountId: UUID!
    """
    The journal detaching from. If not provided this will detach from default journal.
    """
    journalId: UUID
  ): VelocityControl

  """
  Add a limit to the control.
  """
  addLimitToControl(
    "The control to add limit to."
    velocityControlId: UUID!
    "The velocity limit to add."
    velocityLimitId: UUID!
  ): VelocityControl

  """
  Remove a single limit from control.
  """
  removeLimitFromControl(
    "The control to remove from."
    velocityControlId: UUID!
    "The velocity limit to remove."
    velocityLimitId: UUID!
  ): VelocityControl

  """
  Remove all limits from the velocity control.
  """
  removeAllLimitsFromControl(
    "The control to remove from."
    velocityControlId: UUID!
  ): VelocityControl
}

enum VelocityControlIndex {
  "Index by `velocityControlId` field. Must supply an `velocityControlId: { eq: <id> }` filter to the `where` object."
  VELOCITY_CONTROL_ID
  "Index by `name` field. Use to apply query filters on the value of `name`."
  NAME
  "Index by `accountId` attached to velocity control. Must supply an `accountId: { eq: <id> }` filter to the `where` object."
  ACCOUNT_ID

  VELOCITY_LIMIT_ID
}

input VelocityControlIndexInput {
  name: VelocityControlIndex!
  sort: SortOrder
}

input VelocityControlFilterInput {
  "Filter on the `velocityControlId` field. Required when using index `VelocityControlIndex.VELOCITY_CONTROL_ID`."
  velocityControlId: FilterValue
  "Filter on the `velocityLimitId` field. Required when using index `VelocityControlIndex.VELOCITY_RULE_ID`."
  velocityLimitId: FilterValue
  "Filter on the `name` field. Required when using index `VelocityControlIndex.NAME`."
  name: FilterValue
  "Filter on attached accounts via `accountId`. Required when using index `VelocityControlIndex.ACCOUNT_ID`."
  accountId: FilterValue
}

enum VelocityLimitIndex {
  "Index by `velocityLimitId` field. Must supply an `velocityLimitId: { eq: <id> }` filter to the `where` object."
  VELOCITY_LIMIT_ID
  "Index by `name` field. Use to apply query filters on the value of `name`."
  NAME
}

input VelocityLimitIndexInput {
  name: VelocityLimitIndex!
  sort: SortOrder
}

input VelocityLimitFilterInput {
  "Filter on the `velocityLimitId` field. Required when using index `VelocityLimitIndex.VELOCITY_RULE_ID`."
  velocityLimitId: FilterValue
  "Filter on the `name` field. Required when using index `VelocityLimitIndex.NAME`."
  name: FilterValue
}

type VelocityControlConnection implements Connection {
  nodes: [VelocityControl]!
  edges: [VelocityControlConnectionEdge]!
  pageInfo: PageInfo!
}

type VelocityControlConnectionEdge {
  cursor: String!
  node: VelocityControl
}

type VelocityLimitConnection implements Connection {
  nodes: [VelocityLimit]!
  edges: [VelocityLimitConnectionEdge]!
  pageInfo: PageInfo!
}

type VelocityLimitConnectionEdge {
  cursor: String!
  node: VelocityLimit
}

type VelocityControl implements Node {
  id: ID!
  "Unique identifier of this control."
  velocityControlId: UUID!
  "Human readable name of this control."
  name: String!
  "Human readable description of this control."
  description: String!
  "The the enforcement this control produces."
  enforcement: VelocityEnforcement!
  """
  A boolean expression indicating if control should enforce.
  The `account`, `transaction`, `balance` and `entry` are available for use in the dimension computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression

  "Set of default velocity limits for this control."
  limits: [VelocityLimit]! @goField(forceResolver: true)
}

type VelocityLimit implements Node {
  id: ID!
  "Unique identifier for this velocity limit."
  velocityLimitId: UUID!

  """
  Human readable name of this limit.
  """
  name: String!

  """
  "
  Human readable description of this limit.
  """
  description: String!

  """
  Group by these values to index the calculation.

  The `account`, `transaction`, `tranCode` and `entry` are available for use in the dimension computation on `context.vars`.
  """
  window: [PartitionKey]!

  """
  A boolean expression indicating if an balance entry should be written.
  The `account`, `transaction` and `entry` are available for use in the dimension computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression

  """
  The limit to enforce.
  """
  limit: Limit!

  """
  The currency this limit  applies to. If an empty string, applies to all limits.
  """
  currency: CurrencyCode!

  """
  Parameters for `VelocityLimit.limit`
  """
  params: [ParamDefinition]
}

input VelocityControlInput {
  "Unique identifier for this velocity control."
  velocityControlId: UUID!
  "Human readable name for this velocity control."
  name: String!
  "Human readable description for this velocity control."
  description: String!
  "The type of enforcement this velocity control generates."
  enforcement: VelocityEnforcementInput!
  """
  A boolean expression indicating if this control should trigger enforcement.
  The `account`, `transaction` and `entry` are available for use on `context.vars`.
  @example("context.vars.transaction.?metadata.skipVelocityControl.orElse(false))")
  """
  condition: Expression

  """
  Add these velocity limits to the control.
  """
  velocityLimitIds: [UUID!]
}

input VelocityLimitInput {
  velocityLimitId: UUID!

  """
  Human readable name of this rule.
  """
  name: String!

  """
  "
  Human readable description of this rule.
  """
  description: String!

  """
  Group by these values to index the calculation.

  The `account`, `transaction`, `tranCode` and `entry` are available for use in the window computation on `context.vars`.
  """
  window: [PartitionKeyInput]!

  """
  A boolean expression indicating if an balance entry should be written.
  The `account`, `transaction` and `entry` are available for use in the window computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression

  """
  The limit to enforce. Can supply different limits based
  """
  limit: LimitInput!

  """
  Currency this limit applies to. If set to empty string, applies limit to all currencies.
  """
  currency: CurrencyCode!

  """
  The parameters for `VelocityLimit.limit`.
  """
  params: [ParamDefinitionInput]

  """
  Add the limit to the velocity controls in this list.
  """
  velocityControlIds: [UUID!]
}

type Limit {
  timestampSource: Expression
  balance: [BalanceLimit!]!
}

input LimitInput {
  """
  Uses a timestamp from the specified source for picking the balance limit.
  By default uses the system `transaction.timestamp`.
  Must resolve to a CEL `timestamp`.
  @example("timestamp(context.vars.transaction.?metadata.ts.orValue(context.transaction.timestamp))")
  """
  timestampSource: Expression
  balance: [BalanceLimitInput!]!
}

input UpdateLimitInput {
  """
  Uses timestamp from the specified source for picking the balance limit.
  By default uses the transaction timestamp.
  Must resolve to a CEL `timestamp`.
  @example("timestamp(context.vars.transaction.?metadata.ts.orValue(context.transaction.timestamp))")
  """
  timestampSource: Expression
  balance: [BalanceLimitInput!]
}

input UpdateVelocityControlInput {
  "If set, updates name of velocity control."
  name: String
  "If set, updates description of velocity control."
  description: String
  "If set, updates the enforcement type of the velocity control."
  enforcement: VelocityEnforcementInput
  "If set, updates the condition for the velocity control."
  condition: Expression
}

input UpdateVelocityLimitInput {
  "If set, updates name of velocity limit."
  name: String
  "If set, updates description of velocity limit."
  description: String
  "If set, updates the limit of the velocity limit."
  limit: UpdateLimitInput
  "If set, sets the currency of the velocity limit. Cannot unset."
  currency: CurrencyCode
  "If Set, sets the condition of the velocity limit."
  condition: Expression
}

enum VelocityEnforcementAction {
  "Returns a selectable exception on postTransaction.exceptions, but allows transaction to be posted."
  WARN
  "Returns a selectable exception on postTransaction.exceptions, and voids offending transaction."
  VOID
  "Returns an exception as an error, aborting entire request."
  REJECT
}

input VelocityEnforcementInput {
  action: VelocityEnforcementAction!
}

type VelocityEnforcement {
  action: VelocityEnforcementAction!
}

enum BalanceLimitType {
  "Limit based on available balance at a particular layer."
  AVAILABLE
}

input BalanceLimitInput {
  """
  The layer this balance limit is enforced at.
  Must resolve to `SETTLED`, `PENDING` or `ENCUMBRANCE`.
  """
  layer: Expression!
  """
  The maximum amount at this layer that can be spent. Must resolve to a decimal.
  """
  amount: Expression!
  """
  The direction this balance enforces on as an upper limit.
  Must resolve to `CREDIT` or `DEBIT`.
  """
  normalBalanceType: Expression!
  """
  The timestamp at which this balance limit begins to be effective.
  If provided, must resolve to a `timestamp`.
  Defaults to the creation stamp of the underlying control.
  @example("timestamp('2022-01-01T14:00:00.000Z')")
  """
  start: Expression
  """
  The timestamp at which this balance limit ceases to be effective.
  If provided, must resolve to a `timestamp`.
  Defaults to infinite timestamp.
  @example("timestamp('2022-01-01T15:00:00.000Z')")
  """
  end: Expression
}

type BalanceLimit {
  "The layer this balance limit is enforced at."
  layer: Expression!
  "The maximum amount at this layer that can be spent."
  amount: Expression!
  "The direction this balance enforces on."
  NormalBalanceType: Expression!
  "The timestamp at which this balance limit begins to be effective."
  start: Expression
  "The timestamp at which this balance limit ceases to be effective."
  end: Expression
}

input VelocityWindowInput {
  "The account or set id to search for velocity."
  accountId: UUID!
  "Limit the search to this velocity control Id."
  velocityControlId: UUID!
  "Limit the search to this velocity limit."
  velocityLimitId: UUID
  """
  The window to search. If `velocityLimitId` not present,
  will return any limit that supports the _entire_ window.
  """
  window: JSON!
  "Return the velocity limit for this currency."
  currency: CurrencyCode! = "USD"
}

type VelocityBalance {
  "The matching velocity control id"
  velocityControlId: UUID!
  "The matching velocity limit."
  velocityLimitId: UUID!
  "The amount spent on the limit."
  spent: Decimal!
  "The amount remaining on the limit."
  remaining: Decimal!
  "The currency of this velocity balance."
  currency: CurrencyCode!
  "Get the velocity limit for this Balance."
  velocityLimit: VelocityLimit!
  "The underlying balance for this velocity."
  balance: Balance!
  "Retrieve the entries in this window."
  entries(first: Int!, after: String): EntryConnection! @goField(forceResolver: true)
}

type ResolvedVelocityControl {
  "Unique identifier of this control."
  velocityControlId: UUID!
  "Journal this velocity control is acting on."
  journalId: UUID!
  "Human readable name of this control"
  name: String!
  "Human readable description of this control."
  description: String!
  "The enforcement this control produces."
  enforcement: VelocityEnforcement!
  """
  A boolean expression indicating if control should enforce control.
  The `account`, `transaction`, `balance` and `entry` are available for use in the dimension computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression
  "Set of resolved limits for this control."
  limits: [ResolvedVelocityLimit!]!
}

type ResolvedVelocityLimit {
  "Calculation identifier for checking balances on this resolved velocity limit"
  calculationId: UUID!

  "Unique identifier for this velocity limit."
  velocityLimitId: UUID!
  """
  Human readable name of this limit.
  """
  name: String!
  """
  "
  Human readable description of this limit.
  """
  description: String!
  """
  A boolean expression indicating if an balance entry should be written.
  The `account`, `transaction` and `entry` are available for use in the dimension computation on `context.vars`.
  @example("has(context.vars.account.metadata.policyPayment)")
  """
  condition: Expression
  """
  Group by these values to index the calculation.

  The `account`, `transaction`, `tranCode` and `entry` are available for use in the dimension computation on `context.vars`.
  """
  window: [PartitionKey!]!
  """
  The currency this limit  applies to. If an empty string, applies to all limits.
  """
  currency: CurrencyCode!
  """
  Parameters for `VelocityLimit.limit`
  """
  params: [ParamDefinition]
  """
  The resolved values for this velocity limit.
  """
  limit: ResolvedLimit!
}

type ResolvedLimit {
  """
  A resolved balance limit.
  """
  balance: [ResolvedBalanceLimit!]!
}

type ResolvedBalanceLimit {
  """
  Layer at which this balance is balance is enforced.
  """
  layer: Layer!
  """
  Decimal amount of the limit.
  """
  amount: Decimal!
  """
  Normal balance direction of this limit.
  """
  normalBalanceType: DebitOrCredit!
  """
  Timestamp of when this limit starts application.
  """
  start: Timestamp!
  """
  Timestamp of when this limit ends application.
  """
  end: Timestamp!
}

type ResolvedVelocityControlConnection implements Connection {
  nodes: [ResolvedVelocityControl]!
  edges: [ResolvedVelocityControlConnectionEdge]!
  pageInfo: PageInfo!
}

type ResolvedVelocityControlConnectionEdge {
  cursor: String!
  node: ResolvedVelocityControl
}

extend type Query {
  "Get entries from a specific view by name."
  view(
    "Name of the view to query."
    name: String!
    "Filters to apply based on the view's dimensions."
    where: ViewFilter
    "Number of nodes to return on the connection."
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor is provided, the query uses the default starting cursor."
    after: String
  ): ViewRecordConnection! @goField(forceResolver: true)
}

"""
Represents a single entry in an view materialized view.
"""
type ViewRecord implements Node {
  """
  Globally unique identifier for this view entry.
  """
  id: ID!

  """
  Name of the view this record is from.
  """
  name: String!

  """
  The document content of this view entry.
  Structure depends on the view definition.
  """
  document: JSON!

  """
  Information about the data source that trigged this version of the document.
  """
  source: ViewTrigger!

  """
  The current version number of this view.
  """
  version: Int!

  _recordId: UUID!

  """
  History of changes to this View record.
  Because ledgers are immutable and append-only, all changes are recorded as sequenced versions of the record, providing an unbroken lineage of the current state.
  """
  history(
    "Number of nodes to return on the connection"
    first: Int!
    "Cursor indicating the start point to retrieve nodes. When no cursor provided, uses default starting cursor"
    after: String
  ): ViewRecordConnection! @goField(forceResolver: true)
}

"""
Connection to a list of ViewEntry nodes.
"""
type ViewRecordConnection implements Connection {
  nodes: [ViewRecord]!
  edges: [ViewRecordConnectionEdge]!
  pageInfo: PageInfo!
}

"""
Edges represent links connecting a parent or query field to a list of ViewEntry nodes.
"""
type ViewRecordConnectionEdge {
  """
  Cursor position at this edge.
  """
  cursor: String!

  """
  Reference to the ViewEntry node at this edge.
  """
  node: ViewRecord
}

type ViewTrigger {
  entity: String!
  trigger: ViewTriggerEnum!
  _oldRecordId: UUID
  _newRecordId: UUID!
  _oldVersion: Int
  _newVersion: Int!

  """
  Resolve the new trigger entity that created this version of the document.
  """
  new: DatabaseEntity! @goField(forceResolver: true)

  """
  Resolve the old trigger entity that created this version of the document.
  """
  old: DatabaseEntity @goField(forceResolver: true)
}

extend type Mutation {
  "Mutations in the `warehouse` namespace are used to manage the twisp data warehouse."
  warehouse: WarehouseMutation!
}

extend type Query {
  "Queries in the `warehouse` namespace are used to perform reads against the twisp data warehouse"
  warehouse: WarehouseQuery!
}

type WarehouseMutation {
  export(input: ExportInput!): Export! @goField(forceResolver: true)
  executeStatementSync(input: ExecuteStatementSyncInput!): ExecuteStatementSyncOutput
    @goField(forceResolver: true)
  batchExecuteStatement(input: BatchExecuteStatementInput!): BatchExecuteStatementOutput
    @goField(forceResolver: true)
  cancelStatement(input: CancelStatementInput!): CancelStatementOutput @goField(forceResolver: true)
  executeStatement(input: ExecuteStatementInput!): ExecuteStatementOutput
    @goField(forceResolver: true)
}

type WarehouseQuery {
  export(id: String!): Export @goField(forceResolver: true)
  describeStatement(input: DescribeStatementInput!): DescribeStatementOutput
    @goField(forceResolver: true)
  describeTable(input: DescribeTableInput!): DescribeTableOutput @goField(forceResolver: true)
  getStatementResult(input: GetStatementResultInput!): GetStatementResultOutput
    @goField(forceResolver: true)
  listDatabases(input: ListDatabasesInput!): ListDatabasesOutput @goField(forceResolver: true)
  listSchemas(input: ListSchemasInput!): ListSchemasOutput @goField(forceResolver: true)
  listStatements(input: ListStatementsInput!): ListStatementsOutput @goField(forceResolver: true)
  listTables(input: ListTablesInput!): ListTablesOutput @goField(forceResolver: true)
}

enum ExportEntity {
  Balance
  Account
  AccountSet
  Transaction
  Entry
  AccountSetMember
  WorkflowExecution
}

enum ExportVersion {
  LATEST
  HISTORICAL
}

enum ExportFormat {
  PARQUET
  JSON
  CSV
}

enum ExportCompression {
  NONE
  GZIP
  BZIP2
  ZSTD
}

input FormatOptions {
  nullAs: String
  header: Boolean
  delimiter: String
}

input TempCredentials {
  accessKeyId: String!
  secretAccessKey: String!
  sessionToken: String!
}

input FilesDestinationInput {
  keyPrefix: String!
}

input DestinationInput {
  files: FilesDestinationInput!
}

input ExportInput {
  """
  Which Entity to export.
  """
  entity: ExportEntity!
  """
  If `HISTORICAL`, exports every version of the entity.
  If `LATEST`, exports the latest version of the entity.
  """
  version: ExportVersion!
  """
  Output format for the export. Reccomend JSON or Parquet.
  """
  format: ExportFormat!
  """
  Compression options for the export. Recommend picking one, for lower read units.
  """
  compression: ExportCompression!
  """
  Destination for export. Currently only files API supported.
  """
  destination: DestinationInput!
  """
  Additional formatting options for export files.
  """
  formatOptions: FormatOptions
  """
  Optionally define export from timestamp.
  Returns records which were created with `timestamp >= fromTimestamp`
  Used together with `toTimestamp` is the half open interval `fromTimestamp >= timestamp && timestamp < toTimestamp`.
  """
  fromTimestamp: Timestamp
  """
  Optionall define export to timestamp.
  Returns records which were created with `timestamp < toTimestamp`
  Used together with `fromTimestamp` is the half open interval `fromTimestamp >= timestamp && timestamp < toTimestamp`.
  """
  toTimestamp: Timestamp
}

type Export {
  id: String!
  status: SqlStatementStatus!
  error: String
}

type SQLRecord {
  # A row of sql data
  fields: [SQLField]
}

# A data value in a column.
type SQLField {
  # enum to indicate the type of the attached value
  type: SQLField_Type!
  # the value as indicated by the type enum
  value: SQLField_Value
}

enum SqlStatementStatus {
  ABORTED
  ALL
  FAILED
  FINISHED
  PICKED
  STARTED
  SUBMITTED
}

enum SQLField_Type {
  IS_NULL
  BYTES
  BOOL
  DOUBLE
  INT
  STRING
}

type SQLField_Value {
  # A value that indicates whether the data is NULL.
  isNull: Boolean
  # A value of the bytes data type.
  bytes: Uint8Array
  # A value of the bool data type.
  bool: Boolean
  # A value of the double data type.
  double: Float
  # A value of the long data type.
  int: Int
  # A value of the string data type.
  str: String
}

# The properties (metadata) of a column.
type SQLColumnMetadata {
  # The default value of the column.
  columnDefault: String
  # A value that indicates whether the column is case-sensitive.
  isCaseSensitive: Boolean!
  # A value that indicates whether the column contains currency values.
  isCurrency: Boolean!
  # A value that indicates whether an integer column is signed.
  isSigned: Boolean!
  # The label for the column.
  label: String
  # The length of the column.
  length: Int!
  # The name of the column.
  name: String
  # A value that indicates whether the column is nullable.
  nullable: Int!
  # The precision value of a decimal number column.
  precision: Int!
  # The scale value of a decimal number column.
  scale: Int!
  # The name of the schema that contains the table that includes the column.
  schemaName: String
  # The name of the table that includes the column.
  tableName: String
  # The database-specific data type of the column.
  typeName: String
}

input ExecuteStatementSyncInput {
  # The SQL statement text to run.
  #
  # This member is required.
  sql: String!
}

type ExecuteStatementSyncOutput {
  # The results of the SQL statement.
  records: [SQLRecord]
  # The properties (metadata) of a column.
  columnMetadata: [SQLColumnMetadata]
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The total number of rows in the result set returned from a query. You can use
  # this number to estimate the number of calls to the GetStatementResult operation
  # needed to page through the results.
  totalNumRows: Int!
}

input BatchExecuteStatementInput {
  # One or more SQL statements to run. The SQL statements are run as a single
  # transaction. They run serially in the order of the array. Subsequent SQL
  # statements don't start until the previous statement in the array completes. If
  # any SQL statement fails, then because they are run as one transaction, all work
  # is rolled back.
  #
  # This member is required.
  sqls: [String!]
}

type BatchExecuteStatementOutput {
  # The date and time (UTC) the statement was created.
  createdAt: Timestamp!
  # The name of the database.
  database: String
  # The database user name.
  dbUser: String
  # The identifier of the SQL statement whose results are to be fetched. This value
  # is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
  # This identifier is returned by BatchExecuteStatment .
  id: String
}

input CancelStatementInput {
  # The identifier of the SQL statement to cancel. This value is a universally
  # unique identifier (UUID) generated by Amazon Redshift Data API. This identifier
  # is returned by BatchExecuteStatment , ExecuteStatment , and ListStatements .
  #
  # This member is required.
  id: String!
}

type CancelStatementOutput {
  # A value that indicates whether the cancel statement succeeded (true).
  status: Boolean
}

input ExecuteStatementInput {
  # The SQL statement text to run.
  #
  # This member is required.
  sql: String!
}

type ExecuteStatementOutput {
  # The date and time (UTC) the statement was created.
  createdAt: Timestamp!
  # The name of the database.
  database: String
  # The database user name.
  dbUser: String
  # The identifier of the SQL statement whose results are to be fetched. This value
  # is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
  id: String
}

input DescribeStatementInput {
  # The identifier of the SQL statement to describe. This value is a universally
  # unique identifier (UUID) generated by Amazon Redshift Data API. A suffix
  # indicates the number of the SQL statement. For example
  # d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the
  # second SQL statement of a batch query. This identifier is returned by
  # BatchExecuteStatment , ExecuteStatement , and ListStatements .
  #
  # This member is required.
  id: String!
}

type DescribeStatementOutput_SubStatement {
  # The date and time (UTC) the statement was created.
  createdAt: Timestamp!
  # The date and time (UTC) that the statement metadata was last updated.
  updatedAt: Timestamp!
  # The amount of time in nanoseconds that the statement ran.
  duration: Int!
  # Either the number of rows returned from the SQL statement or the number of rows
  # affected. If result size is greater than zero, the result rows can be the number
  # of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and
  # others. A -1 indicates the value is null.
  resultRows: Int!
  # The size in bytes of the returned results. A -1 indicates the value is null.
  resultSize: Int!
  # The status of the SQL statement. An example is the that the SQL statement
  # finished.
  status: SqlStatementStatus!
  # A value that indicates whether the statement has a result set. The result set
  # can be empty. The value is true for an empty result set.
  hasResultSet: Boolean
  # The error message from the cluster if the SQL statement encountered an error
  # while running.
  error: String
  # The identifier of the SQL statement. This value is a universally unique
  # identifier (UUID) generated by Amazon Redshift Data API. A suffix indicates the
  # number of the SQL statement. For example, d9b6c0c9-0747-4bf4-b142-e8883122f766:2
  # has a suffix of :2 that indicates the second SQL statement of a batch query.
  id: String
  # The SQL statement text.
  queryString: String
}

type DescribeStatementOutput {
  # The date and time (UTC) when the SQL statement was submitted to run.
  createdAt: Timestamp!
  # The date and time (UTC) that the metadata for the SQL statement was last
  # updated. An example is the time the status last changed.
  updatedAt: Timestamp!
  # The amount of time in nanoseconds that the statement ran.
  duration: Int!
  # Either the number of rows returned from the SQL statement or the number of rows
  # affected. If result size is greater than zero, the result rows can be the number
  # of rows affected by SQL statements such as INSERT, UPDATE, DELETE, COPY, and
  # others. A -1 indicates the value is null.
  resultRows: Int!
  # The size in bytes of the returned results. A -1 indicates the value is null.
  resultSize: Int!
  # The status of the SQL statement being described. Status values are defined as
  # follows:
  #   - ABORTED - The query run was stopped by the user.
  #   - ALL - A status value that includes all query statuses. This value can be
  #   used to filter results.
  #   - FAILED - The query run failed.
  #   - FINISHED - The query has finished running.
  #   - PICKED - The query has been chosen to be run.
  #   - STARTED - The query run has started.
  #   - SUBMITTED - The query was submitted, but not yet processed.
  status: SqlStatementStatus!
  # A value that indicates whether the statement has a result set. The result set
  # can be empty. The value is true for an empty result set. The value is true if
  # any substatement returns a result set.
  hasResultSet: Boolean
  # The name of the database.
  database: String
  # The database user name.
  dbUser: String
  # The error message from the cluster if the SQL statement encountered an error
  # while running.
  error: String
  id: String
  # The SQL statement text.
  queryString: String
  # The serverless workgroup name or Amazon Resource Name (ARN).
  workgroupName: String
  # The SQL statements from a multiple statement run.
  subStatements: [DescribeStatementOutput_SubStatement]
}

input DescribeTableInput {
  # The name of the database that contains the tables to be described. If
  # ConnectedDatabase is not specified, this is also the database to connect to with
  # your authentication credentials.
  #
  # This member is required.
  database: String!
  # The maximum number of tables to return in the response. If more tables exist
  # than fit in one response, then NextToken is returned to page through the
  # results.
  maxResults: Int!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The schema that contains the table. If no schema is specified, then matching
  # tables for all schemas are returned.
  schema: String
  # The table name. If no table is specified, then all tables for all matching
  # schemas are returned. If no table and no schema is specified, then all tables
  # for all schemas in the database are returned
  table: String
}

type DescribeTableOutput {
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # A list of columns in the table.
  columnList: [SQLColumnMetadata]
}

input GetStatementResultInput {
  # The identifier of the SQL statement whose results are to be fetched. This value
  # is a universally unique identifier (UUID) generated by Amazon Redshift Data API.
  # A suffix indicates then number of the SQL statement. For example
  # d9b6c0c9-0747-4bf4-b142-e8883122f766:2 has a suffix of :2 that indicates the
  # second SQL statement of a batch query. This identifier is returned by
  # BatchExecuteStatment , ExecuteStatment , and ListStatements .
  #
  # This member is required.
  id: String!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
}

type GetStatementResultOutput {
  # The results of the SQL statement.
  records: [SQLRecord]
  # The properties (metadata) of a column.
  columnMetadata: [SQLColumnMetadata]
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The total number of rows in the result set returned from a query. You can use
  # this number to estimate the number of calls to the GetStatementResult operation
  # needed to page through the results.
  totalNumRows: Int!
}

input ListDatabasesInput {
  # The maximum number of databases to return in the response. If more databases
  # exist than fit in one response, then NextToken is returned to page through the
  # results.
  maxResults: Int!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
}

type ListDatabasesOutput {
  # The names of databases.
  databases: [String!]
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
}

input ListSchemasInput {
  # The maximum number of schemas to return in the response. If more schemas exist
  # than fit in one response, then NextToken is returned to page through the
  # results.
  maxResults: Int!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # A pattern to filter results by schema name. Within a schema pattern, "%" means
  # match any substring of 0 or more characters and "_" means match any one
  # character. Only schema name entries matching the search pattern are returned.
  schemaPattern: String
  # The name of the database that contains the schemas to list. If ConnectedDatabase
  # is not specified, this is also the database to connect to with your
  # authentication credentials.
  #
  # This member is required.
  database: String!
}

type ListSchemasOutput {
  # The schemas that match the request pattern.
  schemas: [String!]
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
}

input ListStatementsInput {
  # The maximum number of SQL statements to return in the response. If more SQL
  # statements exist than fit in one response, then NextToken is returned to page
  # through the results.
  maxResults: Int!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The name of the SQL statement specified as input to BatchExecuteStatement or
  # ExecuteStatement to identify the query. You can list multiple statements by
  # providing a prefix that matches the beginning of the statement name. For
  # example, to list myStatement1, myStatement2, myStatement3, and so on, then
  # provide the a value of myStatement . Data API does a case-sensitive match of SQL
  # statement names to the prefix value you provide.
  statementName: String
  # The status of the SQL statement to list. Status values are defined as follows:
  #   - ABORTED - The query run was stopped by the user.
  #   - ALL - A status value that includes all query statuses. This value can be
  #   used to filter results.
  #   - FAILED - The query run failed.
  #   - FINISHED - The query has finished running.
  #   - PICKED - The query has been chosen to be run.
  #   - STARTED - The query run has started.
  #   - SUBMITTED - The query was submitted, but not yet processed.
  status: SqlStatementStatus!
}

type ListStatementsOutput_Statement {
  # The SQL statement identifier. This value is a universally unique identifier
  # (UUID) generated by Amazon Redshift Data API.
  id: String
  # The date and time (UTC) the statement was created.
  createdAt: Timestamp!
  # A value that indicates whether the statement is a batch query request.
  isBatchStatement: Boolean
  # The SQL statement.
  queryString: String
  # One or more SQL statements. Each query string in the array corresponds to one
  # of the queries in a batch query request.
  queryStrings: [String!]
  # The name of the SQL statement.
  statementName: String
  # The status of the SQL statement. An example is the that the SQL statement
  # finished.
  status: SqlStatementStatus!
  # The date and time (UTC) that the statement metadata was last updated.
  updatedAt: Timestamp!
}

type ListStatementsOutput {
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The SQL statements.
  statements: [ListStatementsOutput_Statement]
}

input ListTablesInput {
  # The maximum number of tables to return in the response. If more tables exist
  # than fit in one response, then NextToken is returned to page through the
  # results.
  maxResults: Int!
  # The name of the database that contains the tables to list. If ConnectedDatabase
  # is not specified, this is also the database to connect to with your
  # authentication credentials.
  #
  # This member is required.
  database: String!
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # A pattern to filter results by schema name. Within a schema pattern, "%" means
  # match any substring of 0 or more characters and "_" means match any one
  # character. Only schema name entries matching the search pattern are returned. If
  # SchemaPattern is not specified, then all tables that match TablePattern are
  # returned. If neither SchemaPattern or TablePattern are specified, then all
  # tables are returned.
  schemaPattern: String
  # A pattern to filter results by table name. Within a table pattern, "%" means
  # match any substring of 0 or more characters and "_" means match any one
  # character. Only table name entries matching the search pattern are returned. If
  # TablePattern is not specified, then all tables that match SchemaPattern are
  # returned. If neither SchemaPattern or TablePattern are specified, then all
  # tables are returned.
  tablePattern: String
}

type ListTablesOutput_Table {
  # The name of the table.
  name: String
  # The schema containing the table.
  schema: String
  # The type of the table. Possible values include TABLE, VIEW, SYSTEM TABLE
  # GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, and SYNONYM.
  type: String
}

type ListTablesOutput {
  # A value that indicates the starting point for the next set of response records
  # in a subsequent request. If a value is returned in a response, you can retrieve
  # the next set of records by providing this returned NextToken value in the next
  # NextToken parameter and retrying the command. If the NextToken field is empty
  # all response records have been retrieved for the request.
  nextToken: String
  # The tables that match the request pattern.
  tables: [ListTablesOutput_Table]
}

extend type Mutation {
  "Mutations in the `workflow` namespace are used to manage and execute workflows."
  workflow: WorkflowMutation!
}

extend type Query {
  workflow: WorkflowQuery!
}

type WorkflowQuery {
  """
  Return the execution by execution id.
  """
  execution(executionId: UUID!): WorkflowExecution @goField(forceResolver: true)
}

type WorkflowMutation {
  "Execute a workflow identified by `workflowId`."
  execute(input: WorkflowInput!): WorkflowExecution! @goField(forceResolver: true)

  "Execution workflow identified by `workflowId` and `executionId` to the state identified by `task`."
  executeTask(input: WorkflowInput!): WorkflowExecution! @goField(forceResolver: true)
}

type WorkflowExecution {
  "Workflow Id of workflow invoked."
  workflowId: UUID!
  "Execution Id of this execution."
  executionId: UUID!
  "The task that was invoked on this version of the workflow execution."
  task: String!
  "Parameters supplied for this workflow execution."
  params: JSON
  "Context to pass along to future executions of this workflow."
  context: JSON
  "Output of this invocation of the workflow."
  output: WorkflowExecutionOutput!
  "Errors from this invocation of the workflow."
  error: String

  "Date and time when the execution was first created."
  created: Timestamp!

  "Time of the last change. Especially useful when reviewing the `history`."
  modified: Timestamp!

  "version number of the execution. Previous versions are tracked in history."
  version: Int!
  _recordId: UUID!

  """
  Activities that this workflow took. It may have inserted entities like Transactions or invoked Workflows.
  """
  activities: [WorkflowActivity] @goField(forceResolver: true)

  """
  Workflow execution history for this workflow.
  """
  history(first: Int!, after: String): WorkflowExecutionConnection! @goField(forceResolver: true)

  ## executeTask BC

  """
  Outputs the execution state of the workflow. Depending on the workflow will contain diagnostic detials specific to the workflow.
  """
  state: JSON!
    @goField(forceResolver: true)
    @deprecated(reason: "This is the same as `WorkflowExecution.output.state`.")

  """
  Resolve any posted transactions that this workflow posted in this invocation.
  """
  transactions(first: Int! = 0): [Transaction]
    @goField(forceResolver: true)
    @deprecated(reason: "Use `WorkflowExecution.activities` instead.")
}

type WorkflowActivity {
  action: String!
  entity: WorkflowEntity! @goField(forceResolver: true)
  entityId: UUID!
  entityType: String!
  _recordId: UUID!
  version: Int!

  _workflowId: UUID!
  _executionId: UUID!
  _executionVersion: Int!
}

type WorkflowExecutionConnection implements Connection {
  nodes: [WorkflowExecution]!
  edges: [WorkflowExecutionConnectionEdge]!
  pageInfo: PageInfo!
}

type WorkflowExecutionConnectionEdge {
  cursor: String!
  node: WorkflowExecution
}

type WorkflowExecutionOutput {
  state: JSON
  entities: [WorkflowExecutionOutputEntity]
    @deprecated(reason: "moved to WorkflowExecution.activities")
}

type WorkflowExecutionOutputEntity {
  action: String!
  entity: WorkflowEntity! @goField(forceResolver: true)
  entityId: UUID!
  entityType: String!
  _recordId: UUID!
  version: Int!
}

union WorkflowEntity = Transaction | WorkflowExecution | AchWorkflowTrace

"Fields to execute a new workflow."
input WorkflowInput {
  workflowId: UUID
  executionId: UUID!
  code: String
  task: String!
  params: JSON
}

